{"ast":null,"code":"import _classCallCheck from\"/Users/johnny/IC/Computing/year2/DRP/drp48/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/johnny/IC/Computing/year2/DRP/drp48/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import{variable,UnaryOperator,BinaryOperator,top}from\"./bools\";export var PlainResolver=/*#__PURE__*/function(){function PlainResolver(){var variables=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[\"A\",\"B\",\"C\",\"D\"];_classCallCheck(this,PlainResolver);this.variables=void 0;this.variables=variables;}_createClass(PlainResolver,[{key:\"generateModel\",value:function generateModel(trees){var provens=this.variables.slice();var disprovens=this.variables.slice();var isParadox=true;generateTruthTables(this.variables).forEach(function(table){if(resolutionAll(trees,table)){provens=provens.filter(function(x){return table[x];});disprovens=disprovens.filter(function(x){return!table[x];});isParadox=false;}});if(isParadox){return undefined;}return{positives:new Set(provens),negatives:new Set(disprovens),unknowns:new Set(this.variables.filter(function(x){return!provens.includes(x)&&!disprovens.includes(x);}))};}},{key:\"canBeProvenBy\",value:function canBeProvenBy(trees,goalTree,expected){var cases=[];generateTruthTables(this.variables).forEach(function(table){var all=resolutionAll(trees,table);var pass=resolution(goalTree,table);if(all){cases.push(pass);}});var isAllTrue=cases.reduce(function(a,b){return a&&b;});var isAllFalse=!cases.reduce(function(a,b){return a||b;});switch(expected){case true:return isAllTrue;case false:return isAllFalse;case undefined:return!isAllTrue&&!isAllFalse;}}},{key:\"isEquivalentTo\",value:function isEquivalentTo(trees,goalTree){var tables=generateTruthTables(this.variables);for(var i=0;i<tables.length;i++){if(resolutionAll(trees,tables[i])!=resolution(goalTree,tables[i])){return false;}}return true;}},{key:\"isAlwaysTrue\",value:function isAlwaysTrue(trees){return this.isEquivalentTo(trees,top());}}]);return PlainResolver;}();function resolutionAll(trees,table){if(trees.length==0){return true;}return trees.map(function(tree){return resolution(tree,table);}).reduce(function(a,b){return a&&b;});}function resolution(tree,table){switch(tree.kind){case\"constant\":return tree.value;case\"variable\":return table[tree.variable];case\"unary\":return UnaryOperator.apply(tree.operator,resolution(tree.child,table));case\"binary\":return BinaryOperator.apply(tree.operator,resolution(tree.left,table),resolution(tree.right,table));}}function bitVectorToTable(bitVector,variables){var table={};for(var i=0;i<variables.length;i++,bitVector>>=1){var set=1&bitVector;table[variables[i]]=set!=0;}return table;}function generateTruthTables(variables){return Array.from(Array(Math.pow(2,variables.length)).keys()).map(function(vector){return bitVectorToTable(vector,variables);});}export function allPossibleTruthTablesOf(model){var tables=[];var unknowns=[];model.unknowns.forEach(function(e){return unknowns.push(e);});Array.from(Array(Math.pow(2,unknowns.length)).keys()).forEach(function(vector){var table={};model.positives.forEach(function(p){return table[p]=true;});model.negatives.forEach(function(n){return table[n]=false;});for(var i=0;i<unknowns.length;i++,vector>>=1){var set=1&vector;table[unknowns[i]]=set!=0;}tables.push(table);});return tables;}export function genTruthTableInStringForBTrees(vars,trees){var body=[];var translateBool=function translateBool(b){return b?\"⊤\":\"⊥\";};var isValid=!trees.includes(undefined);generateTruthTables(vars).forEach(function(table){var row=[];vars.forEach(function(v){return row.push(translateBool(table[v]));});row.push(isValid?translateBool(resolutionAll(trees,table)):\"?\");body.push(row);});return{headers:vars.concat(\"val\"),body:body};}","map":{"version":3,"sources":["/Users/johnny/IC/Computing/year2/DRP/drp48/src/server/gameApp/logicResolver/plainResolver.ts"],"names":["variable","UnaryOperator","BinaryOperator","top","PlainResolver","variables","trees","provens","slice","disprovens","isParadox","generateTruthTables","forEach","table","resolutionAll","filter","x","undefined","positives","Set","negatives","unknowns","includes","goalTree","expected","cases","all","pass","resolution","push","isAllTrue","reduce","a","b","isAllFalse","tables","i","length","isEquivalentTo","map","tree","kind","value","apply","operator","child","left","right","bitVectorToTable","bitVector","set","Array","from","keys","vector","allPossibleTruthTablesOf","model","e","p","n","genTruthTableInStringForBTrees","vars","body","translateBool","isValid","row","v","headers","concat"],"mappings":"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","sourcesContent":["import { BoolTree, variable, UnaryOperator, BinaryOperator, and, implies, top } from \"./bools\"\nimport { Resolver, Model } from \"./resolver\"\nimport { Card, TruthTableInString } from \"../../../types\"\n\nexport type TruthTable = { [variable: string]: boolean }\nexport type TruthTableResults = [TruthTable, boolean]\n\ntype BitVector = number\n\nexport class PlainResolver implements Resolver {\n  variables: string[]\n  constructor(variables: string[] = [\"A\", \"B\", \"C\", \"D\"]) {\n    this.variables = variables\n  }\n  generateModel(trees: BoolTree[]): Model | undefined {\n    let provens: string[] = this.variables.slice()\n    let disprovens: string[] = this.variables.slice()\n    let isParadox = true\n    generateTruthTables(this.variables).forEach(table => {\n      if (resolutionAll(trees, table)) {\n        provens = provens.filter(x => table[x])\n        disprovens = disprovens.filter(x => !table[x])\n        isParadox = false\n      }\n    })\n    if (isParadox) {\n      return undefined\n    }\n    return { \n      positives: new Set(provens), \n      negatives: new Set(disprovens), \n      unknowns: new Set(this.variables.filter(x => !provens.includes(x) && !disprovens.includes(x)))\n    }\n  }\n\n  canBeProvenBy(trees: BoolTree[], goalTree: BoolTree, expected: boolean | undefined): boolean {\n    let cases: boolean[] = []\n    generateTruthTables(this.variables).forEach(table => {\n      const all = resolutionAll(trees, table)\n      const pass = resolution(goalTree, table)\n      if (all) {\n        cases.push(pass) \n      }\n    })\n    const isAllTrue = cases.reduce((a, b) => a && b)\n    const isAllFalse = !cases.reduce((a, b) => a || b)\n    switch(expected) {\n      case true: return isAllTrue\n      case false: return isAllFalse\n      case undefined: return !isAllTrue && !isAllFalse\n    }\n  }\n\n  isEquivalentTo(trees: BoolTree[], goalTree: BoolTree): boolean {\n    const tables = generateTruthTables(this.variables)\n    for (let i = 0; i < tables.length; i++) {\n      if (resolutionAll(trees, tables[i]) != resolution(goalTree, tables[i])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isAlwaysTrue(trees: BoolTree[]): boolean {\n    return this.isEquivalentTo(trees, top())\n  }\n\n}\n\n\n\nfunction resolutionAll(trees: BoolTree[], table: TruthTable): boolean {\n  if (trees.length == 0) {\n    return true\n  }\n  return trees.map(tree => resolution(tree, table)).reduce((a, b) => a && b)\n}\n\nfunction resolution(tree: BoolTree, table: TruthTable): boolean {\n  switch(tree.kind) {\n    case \"constant\": \n      return tree.value\n    case \"variable\":\n      return table[tree.variable]\n    case \"unary\":\n      return UnaryOperator.apply(tree.operator, resolution(tree.child, table))\n    case \"binary\":\n      return BinaryOperator.apply(tree.operator, resolution(tree.left, table), resolution(tree.right, table))\n  }\n}\n\nfunction bitVectorToTable(bitVector: BitVector, variables: string[]): TruthTable {\n  let table: TruthTable = {}\n  for(let i = 0; i < variables.length; i++, bitVector >>= 1) {\n    let set = 1 & bitVector\n    table[variables[i]] = set != 0\n  }\n  return table\n}\n\nfunction generateTruthTables(variables: string[]): TruthTable[] {\n  return Array.from(Array(2 ** variables.length).keys())\n    .map(vector => bitVectorToTable(vector, variables))\n}\n\nexport function allPossibleTruthTablesOf(model: Model): TruthTable[] {\n  const tables: TruthTable[] = []\n  const unknowns: string[] = []\n  model.unknowns.forEach(e => unknowns.push(e))\n  Array.from(Array(2 ** unknowns.length).keys()).forEach(vector => {\n    const table: TruthTable = {}\n    model.positives.forEach(p => table[p] = true)\n    model.negatives.forEach(n => table[n] = false)\n    for(let i = 0; i < unknowns.length; i++, vector >>= 1) {\n      let set = 1 & vector\n      table[unknowns[i]] = set != 0\n    }\n    tables.push(table)\n  })\n  return tables\n}\n\nexport function genTruthTableInStringForBTrees(vars: Card[], trees: (BoolTree | undefined)[]): TruthTableInString {\n  const body: string[][] = []\n  const translateBool = (b: boolean) => b ? \"⊤\" : \"⊥\"\n  const isValid = !trees.includes(undefined)\n  generateTruthTables(vars).forEach(table => {\n    const row: string[] = []\n    vars.forEach(v => row.push(translateBool(table[v])))\n    row.push(isValid ? translateBool(resolutionAll(trees as BoolTree[], table)) : \"?\")\n    body.push(row)\n  })\n  return { headers: (vars as string[]).concat(\"val\"), body: body }\n}"]},"metadata":{},"sourceType":"module"}