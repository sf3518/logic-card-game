{"ast":null,"code":"import { variable, top } from \"../logicResolver/bools\";\nexport function parsePremise(premise, variables, operatorTable) {\n  if (premise.length == 0) {\n    return top();\n  }\n\n  const isParenCard = c => c == \")\" || c == \"(\";\n\n  premise.forEach(card => {\n    if (!variables.includes(card) && !operatorTable.isOperator(card) && !isParenCard(card)) {\n      throw Error(\"Unexpected card: \" + card);\n    }\n  });\n  return parsePremiseSection(premise, operatorTable, 0, premise.length - 1);\n} // Parse the premise with in a given section suggested by @start and \n// @end (both inclusive), with the provided OperatorTable.\n// Returns the BoolTree if the Parsing is successful.\n\nfunction parsePremiseSection(premise, operatorTable, start, end) {\n  if (start > end) {\n    throw new Error(\"premise parse error\");\n  }\n\n  let pc = undefined;\n  let parenStack = 0; // scan through the given section to determine pc\n\n  for (let i = start; i <= end; i++) {\n    let card = premise[i];\n\n    switch (card) {\n      case \"(\":\n        parenStack += 1;\n        break;\n\n      case \")\":\n        parenStack -= 1; // check if parens are unmatched\n\n        if (parenStack < 0) {\n          throw new Error(\"unmatched parentheses\");\n        }\n\n        break;\n\n      default:\n        if (parenStack == 0 && operatorTable.isBinaryOperator(card)) {\n          let {\n            precedence: p,\n            fixivity: fix,\n            nodeFunc: nodeFunc\n          } = operatorTable.binOpDic[card];\n\n          if (pc == undefined || pc.precedence < p || pc.precedence == p && pc.fixivity == 'infixl') {\n            // update pc \n            pc = {\n              card: card,\n              index: i,\n              precedence: p,\n              fixivity: fix,\n              constructor: nodeFunc\n            };\n          }\n        }\n\n        break;\n    }\n  }\n\n  if (parenStack != 0) {\n    throw new Error(\"unmatched parentheses\");\n  } // If principle connector exists \n  // parse lhs and rhs of the pc within this section\n  // return constructor(lhs, rhs)\n\n\n  if (pc != undefined) {\n    const left = parsePremiseSection(premise, operatorTable, start, pc.index - 1);\n    const right = parsePremiseSection(premise, operatorTable, pc.index + 1, end);\n    return pc.constructor(left, right);\n  } // If the section given is covered by a pair of parentheses\n  // Parse the section within that pair of parentheses\n\n\n  if (premise[start] == \"(\" && premise[end] == \")\") {\n    return parsePremiseSection(premise, operatorTable, start + 1, end - 1);\n  } // If the first card in this section is a unary operator card\n\n\n  const head = premise[start];\n\n  if (operatorTable.isUnaryOperator(head)) {\n    const child = parsePremiseSection(premise, operatorTable, start + 1, end);\n    return operatorTable.unaryOps[head].nodeFunc(child);\n  } // If the section only contain 1 card, and that card is a variable\n\n\n  if (start == end) {\n    return variable(head);\n  } // Otherwise, there is an error\n\n\n  throw new Error(\"parse error\");\n}","map":{"version":3,"sources":["/Users/johnny/IC/Computing/DRP/drp48/src/server/gameApp/game/premise.ts"],"names":["variable","top","parsePremise","premise","variables","operatorTable","length","isParenCard","c","forEach","card","includes","isOperator","Error","parsePremiseSection","start","end","pc","undefined","parenStack","i","isBinaryOperator","precedence","p","fixivity","fix","nodeFunc","binOpDic","index","constructor","left","right","head","isUnaryOperator","child","unaryOps"],"mappings":"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","sourcesContent":["import { Card, Premise } from \"../../../types\"\nimport { BoolTree, variable, top } from \"../logicResolver/bools\"\nimport { OperatorTable, Fixivity, BinaryConstructor } from \"./operatorTable\"\n\n\nexport function parsePremise(\n  premise: Premise,\n  variables: Card[], \n  operatorTable: OperatorTable\n): BoolTree | never {\n  if (premise.length == 0) {\n    return top()\n  }\n  const isParenCard = (c: Card) => c == \")\" || c == \"(\"\n  premise.forEach(card => {\n    if (!variables.includes(card) \n    && !operatorTable.isOperator(card) \n    && !isParenCard(card)) {\n      throw Error(\"Unexpected card: \" + card)\n    }\n  })\n  return parsePremiseSection(premise, operatorTable, 0, premise.length - 1)\n}\n\n// Parse the premise with in a given section suggested by @start and \n// @end (both inclusive), with the provided OperatorTable.\n// Returns the BoolTree if the Parsing is successful.\nfunction parsePremiseSection(\n  premise: Premise, \n  operatorTable: OperatorTable, \n  start: number, \n  end: number\n): BoolTree | never {\n\n  if (start > end) {\n    throw new Error(\"premise parse error\")\n  }\n\n  type PcInfo = { \n    card: Card, \n    index: number, \n    precedence: number, \n    fixivity: Fixivity, \n    constructor: BinaryConstructor \n  }\n\n  let pc: PcInfo | undefined = undefined\n  let parenStack = 0\n  \n  // scan through the given section to determine pc\n  for (let i = start; i <= end; i++) {\n    let card = premise[i]\n    switch(card) {\n      case \"(\":\n        parenStack += 1\n        break\n      case \")\":\n        parenStack -= 1\n        // check if parens are unmatched\n        if (parenStack < 0) {\n          throw new Error(\"unmatched parentheses\")\n        }\n        break\n      default:\n        if (parenStack == 0 && operatorTable.isBinaryOperator(card)) {\n          let { precedence: p, fixivity: fix, nodeFunc: nodeFunc } = operatorTable.binOpDic[card] \n          if (pc == undefined\n          || pc.precedence < p \n          || pc.precedence == p && pc.fixivity == 'infixl') {\n            // update pc \n            pc = {\n              card: card,\n              index: i,\n              precedence: p,\n              fixivity: fix,\n              constructor: nodeFunc\n            }\n          }\n        }\n        break\n    }\n  }\n\n  if (parenStack != 0) {\n    throw new Error(\"unmatched parentheses\")\n  }\n\n  // If principle connector exists \n  // parse lhs and rhs of the pc within this section\n  // return constructor(lhs, rhs)\n  if (pc != undefined) {\n    const left = parsePremiseSection(premise, operatorTable, start, pc.index - 1)\n    const right = parsePremiseSection(premise, operatorTable, pc.index + 1, end)\n    return pc.constructor(left, right)\n  }\n  \n  // If the section given is covered by a pair of parentheses\n  // Parse the section within that pair of parentheses\n  if (premise[start] == \"(\" && premise[end] == \")\") {\n    return parsePremiseSection(premise, operatorTable, start + 1, end - 1)\n  } \n\n  // If the first card in this section is a unary operator card\n  const head = premise[start]\n  if (operatorTable.isUnaryOperator(head)) {\n    const child = parsePremiseSection(premise, operatorTable, start + 1, end)\n    return operatorTable.unaryOps[head].nodeFunc(child)\n  }\n\n  // If the section only contain 1 card, and that card is a variable\n  if (start == end) {\n    return variable(head)\n  }\n\n  // Otherwise, there is an error\n  throw new Error(\"parse error\")\n\n}"]},"metadata":{},"sourceType":"module"}