{"ast":null,"code":"import { variable, UnaryOperator, BinaryOperator } from \"./bools\";\nexport class PlainResolver {\n  constructor(variables = [\"A\", \"B\", \"C\", \"D\"]) {\n    this.variables = void 0;\n    this.variables = variables;\n  }\n\n  generateModel(trees) {\n    let provens = this.variables.slice();\n    let disprovens = this.variables.slice();\n    let isParadox = true;\n    generateTruthTables(this.variables).forEach(table => {\n      if (resolutionAll(trees, table)) {\n        provens = provens.filter(x => table[x]);\n        disprovens = disprovens.filter(x => !table[x]);\n        isParadox = false;\n      }\n    });\n\n    if (isParadox) {\n      return undefined;\n    }\n\n    return {\n      positives: new Set(provens),\n      negatives: new Set(disprovens),\n      unknowns: new Set(this.variables.filter(x => !provens.includes(x) && !disprovens.includes(x)))\n    };\n  }\n\n}\n\nfunction resolutionAll(trees, table) {\n  return trees.map(tree => resolution(tree, table)).reduce((a, b) => a && b);\n}\n\nfunction resolution(tree, table) {\n  switch (tree.kind) {\n    case \"constant\":\n      return tree.value;\n\n    case \"variable\":\n      return table[tree.variable];\n\n    case \"unary\":\n      return UnaryOperator.apply(tree.operator, resolution(tree.child, table));\n\n    case \"binary\":\n      return BinaryOperator.apply(tree.operator, resolution(tree.left, table), resolution(tree.right, table));\n  }\n}\n\nfunction bitVectorToTable(bitVector, variables) {\n  let table = {};\n\n  for (let i = 0; i < variables.length; i++, bitVector >>= 1) {\n    let set = 1 & bitVector;\n    table[variables[i]] = set != 0;\n  }\n\n  return table;\n}\n\nfunction generateTruthTables(variables) {\n  return Array.from(Array(2 ** variables.length).keys()).map(vector => bitVectorToTable(vector, variables));\n}\n\nexport function allPossibleTruthTablesOf(model) {\n  const tables = [];\n  const unknowns = [];\n  model.unknowns.forEach(e => unknowns.push(e));\n  Array.from(Array(2 ** unknowns.length).keys()).forEach(vector => {\n    const table = {};\n    model.positives.forEach(p => table[p] = true);\n    model.negatives.forEach(n => table[n] = false);\n\n    for (let i = 0; i < unknowns.length; i++, vector >>= 1) {\n      let set = 1 & vector;\n      table[unknowns[i]] = set != 0;\n    }\n\n    tables.push(table);\n  });\n  return tables;\n}\nexport function modelProves(model, btree) {\n  const tables = allPossibleTruthTablesOf(model);\n  const result = tables.map(table => resolution(btree, table));\n\n  if (result.every(it => it)) {\n    return true;\n  }\n\n  if (result.every(it => !it)) {\n    return false;\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["/Users/johnny/IC/Computing/DRP/drp48/src/server/gameApp/logicResolver/plainResolver.ts"],"names":["variable","UnaryOperator","BinaryOperator","PlainResolver","constructor","variables","generateModel","trees","provens","slice","disprovens","isParadox","generateTruthTables","forEach","table","resolutionAll","filter","x","undefined","positives","Set","negatives","unknowns","includes","map","tree","resolution","reduce","a","b","kind","value","apply","operator","child","left","right","bitVectorToTable","bitVector","i","length","set","Array","from","keys","vector","allPossibleTruthTablesOf","model","tables","e","push","p","n","modelProves","btree","result","every","it"],"mappings":"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","sourcesContent":["import { BoolTree, variable, UnaryOperator, BinaryOperator } from \"./bools\"\nimport { Resolver, Model } from \"./resolver\"\n\nexport type TruthTable = { [variable: string]: boolean }\ntype BitVector = number\n\nexport class PlainResolver implements Resolver {\n  variables: string[]\n  constructor(variables: string[] = [\"A\", \"B\", \"C\", \"D\"]) {\n    this.variables = variables\n  }\n  generateModel(trees: BoolTree[]): Model | undefined {\n    let provens: string[] = this.variables.slice()\n    let disprovens: string[] = this.variables.slice()\n    let isParadox = true\n    generateTruthTables(this.variables).forEach(table => {\n      if (resolutionAll(trees, table)) {\n        provens = provens.filter(x => table[x])\n        disprovens = disprovens.filter(x => !table[x])\n        isParadox = false\n      }\n    })\n    if (isParadox) {\n      return undefined\n    }\n    return { \n      positives: new Set(provens), \n      negatives: new Set(disprovens), \n      unknowns: new Set(this.variables.filter(x => !provens.includes(x) && !disprovens.includes(x)))\n    }\n  }\n}\n\nfunction resolutionAll(trees: BoolTree[], table: TruthTable): boolean {\n  return trees.map(tree => resolution(tree, table)).reduce((a, b) => a && b)\n}\n\nfunction resolution(tree: BoolTree, table: TruthTable): boolean {\n  switch(tree.kind) {\n    case \"constant\": \n      return tree.value\n    case \"variable\":\n      return table[tree.variable]\n    case \"unary\":\n      return UnaryOperator.apply(tree.operator, resolution(tree.child, table))\n    case \"binary\":\n      return BinaryOperator.apply(tree.operator, resolution(tree.left, table), resolution(tree.right, table))\n  }\n}\n\nfunction bitVectorToTable(bitVector: BitVector, variables: string[]): TruthTable {\n  let table: TruthTable = {}\n  for(let i = 0; i < variables.length; i++, bitVector >>= 1) {\n    let set = 1 & bitVector\n    table[variables[i]] = set != 0\n  }\n  return table\n}\n\nfunction generateTruthTables(variables: string[]): TruthTable[] {\n  return Array.from(Array(2 ** variables.length).keys())\n    .map(vector => bitVectorToTable(vector, variables))\n}\n\nexport function allPossibleTruthTablesOf(model: Model): TruthTable[] {\n  const tables: TruthTable[] = []\n  const unknowns: string[] = []\n  model.unknowns.forEach(e => unknowns.push(e))\n  Array.from(Array(2 ** unknowns.length).keys()).forEach(vector => {\n    const table: TruthTable = {}\n    model.positives.forEach(p => table[p] = true)\n    model.negatives.forEach(n => table[n] = false)\n    for(let i = 0; i < unknowns.length; i++, vector >>= 1) {\n      let set = 1 & vector\n      table[unknowns[i]] = set != 0\n    }\n    tables.push(table)\n  })\n  return tables\n}\n\nexport function modelProves(model: Model, btree: BoolTree): boolean | undefined {\n  const tables = allPossibleTruthTablesOf(model)\n  const result = tables.map(table => resolution(btree, table))\n  if (result.every(it => it)) {\n    return true\n  }\n\n  if (result.every(it => !it)) {\n    return false\n  }\n\n  return undefined\n\n}"]},"metadata":{},"sourceType":"module"}