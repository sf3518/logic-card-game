{"ast":null,"code":"import { variable, UnaryOperator, BinaryOperator, and } from \"./bools\";\nexport class PlainResolver {\n  constructor(variables = [\"A\", \"B\", \"C\", \"D\"]) {\n    this.variables = void 0;\n    this.variables = variables;\n  }\n\n  generateModel(trees) {\n    let provens = this.variables.slice();\n    let disprovens = this.variables.slice();\n    let isParadox = true;\n    generateTruthTables(this.variables).forEach(table => {\n      if (resolutionAll(trees, table)) {\n        provens = provens.filter(x => table[x]);\n        disprovens = disprovens.filter(x => !table[x]);\n        isParadox = false;\n      }\n    });\n\n    if (isParadox) {\n      return undefined;\n    }\n\n    return {\n      positives: new Set(provens),\n      negatives: new Set(disprovens),\n      unknowns: new Set(this.variables.filter(x => !provens.includes(x) && !disprovens.includes(x)))\n    };\n  }\n\n  canBeProvenBy(trees, goalTree) {\n    const cluster = trees.reduce((a, b) => and(a, b));\n    let isProven = true;\n    generateTruthTables(this.variables).forEach(table => {\n      const all = resolutionAll(trees, table);\n      const pass = resolution(goalTree, table);\n      isProven = isProven && (!all || pass);\n    });\n    return isProven;\n  }\n\n}\n\nfunction resolutionAll(trees, table) {\n  return trees.map(tree => resolution(tree, table)).reduce((a, b) => a && b);\n}\n\nfunction resolution(tree, table) {\n  switch (tree.kind) {\n    case \"constant\":\n      return tree.value;\n\n    case \"variable\":\n      return table[tree.variable];\n\n    case \"unary\":\n      return UnaryOperator.apply(tree.operator, resolution(tree.child, table));\n\n    case \"binary\":\n      return BinaryOperator.apply(tree.operator, resolution(tree.left, table), resolution(tree.right, table));\n  }\n}\n\nfunction bitVectorToTable(bitVector, variables) {\n  let table = {};\n\n  for (let i = 0; i < variables.length; i++, bitVector >>= 1) {\n    let set = 1 & bitVector;\n    table[variables[i]] = set != 0;\n  }\n\n  return table;\n}\n\nfunction generateTruthTables(variables) {\n  return Array.from(Array(2 ** variables.length).keys()).map(vector => bitVectorToTable(vector, variables));\n}\n\nexport function allPossibleTruthTablesOf(model) {\n  const tables = [];\n  const unknowns = [];\n  model.unknowns.forEach(e => unknowns.push(e));\n  Array.from(Array(2 ** unknowns.length).keys()).forEach(vector => {\n    const table = {};\n    model.positives.forEach(p => table[p] = true);\n    model.negatives.forEach(n => table[n] = false);\n\n    for (let i = 0; i < unknowns.length; i++, vector >>= 1) {\n      let set = 1 & vector;\n      table[unknowns[i]] = set != 0;\n    }\n\n    tables.push(table);\n  });\n  return tables;\n}\nexport function modelProves(model, btree) {\n  const tables = allPossibleTruthTablesOf(model);\n  const result = tables.map(table => resolution(btree, table));\n\n  if (result.every(it => it)) {\n    return true;\n  }\n\n  if (result.every(it => !it)) {\n    return false;\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["/Users/johnny/IC/Computing/DRP/drp48/src/server/gameApp/logicResolver/plainResolver.ts"],"names":["variable","UnaryOperator","BinaryOperator","and","PlainResolver","constructor","variables","generateModel","trees","provens","slice","disprovens","isParadox","generateTruthTables","forEach","table","resolutionAll","filter","x","undefined","positives","Set","negatives","unknowns","includes","canBeProvenBy","goalTree","cluster","reduce","a","b","isProven","all","pass","resolution","map","tree","kind","value","apply","operator","child","left","right","bitVectorToTable","bitVector","i","length","set","Array","from","keys","vector","allPossibleTruthTablesOf","model","tables","e","push","p","n","modelProves","btree","result","every","it"],"mappings":"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","sourcesContent":["import { BoolTree, variable, UnaryOperator, BinaryOperator, and, implies } from \"./bools\"\nimport { Resolver, Model } from \"./resolver\"\n\nexport type TruthTable = { [variable: string]: boolean }\nexport type TruthTableResults = [TruthTable, boolean]\n\ntype BitVector = number\n\nexport class PlainResolver implements Resolver {\n  variables: string[]\n  constructor(variables: string[] = [\"A\", \"B\", \"C\", \"D\"]) {\n    this.variables = variables\n  }\n  generateModel(trees: BoolTree[]): Model | undefined {\n    let provens: string[] = this.variables.slice()\n    let disprovens: string[] = this.variables.slice()\n    let isParadox = true\n    generateTruthTables(this.variables).forEach(table => {\n      if (resolutionAll(trees, table)) {\n        provens = provens.filter(x => table[x])\n        disprovens = disprovens.filter(x => !table[x])\n        isParadox = false\n      }\n    })\n    if (isParadox) {\n      return undefined\n    }\n    return { \n      positives: new Set(provens), \n      negatives: new Set(disprovens), \n      unknowns: new Set(this.variables.filter(x => !provens.includes(x) && !disprovens.includes(x)))\n    }\n  }\n\n  canBeProvenBy(trees: BoolTree[], goalTree: BoolTree): boolean {\n    const cluster = trees.reduce((a, b) => and(a, b))\n    let isProven = true\n    generateTruthTables(this.variables).forEach(table => {\n      const all = resolutionAll(trees, table)\n      const pass = resolution(goalTree, table)\n      isProven = isProven && (!all || pass) \n    })\n    return isProven\n  }\n}\n\nfunction resolutionAll(trees: BoolTree[], table: TruthTable): boolean {\n  return trees.map(tree => resolution(tree, table)).reduce((a, b) => a && b)\n}\n\nfunction resolution(tree: BoolTree, table: TruthTable): boolean {\n  switch(tree.kind) {\n    case \"constant\": \n      return tree.value\n    case \"variable\":\n      return table[tree.variable]\n    case \"unary\":\n      return UnaryOperator.apply(tree.operator, resolution(tree.child, table))\n    case \"binary\":\n      return BinaryOperator.apply(tree.operator, resolution(tree.left, table), resolution(tree.right, table))\n  }\n}\n\nfunction bitVectorToTable(bitVector: BitVector, variables: string[]): TruthTable {\n  let table: TruthTable = {}\n  for(let i = 0; i < variables.length; i++, bitVector >>= 1) {\n    let set = 1 & bitVector\n    table[variables[i]] = set != 0\n  }\n  return table\n}\n\nfunction generateTruthTables(variables: string[]): TruthTable[] {\n  return Array.from(Array(2 ** variables.length).keys())\n    .map(vector => bitVectorToTable(vector, variables))\n}\n\nexport function allPossibleTruthTablesOf(model: Model): TruthTable[] {\n  const tables: TruthTable[] = []\n  const unknowns: string[] = []\n  model.unknowns.forEach(e => unknowns.push(e))\n  Array.from(Array(2 ** unknowns.length).keys()).forEach(vector => {\n    const table: TruthTable = {}\n    model.positives.forEach(p => table[p] = true)\n    model.negatives.forEach(n => table[n] = false)\n    for(let i = 0; i < unknowns.length; i++, vector >>= 1) {\n      let set = 1 & vector\n      table[unknowns[i]] = set != 0\n    }\n    tables.push(table)\n  })\n  return tables\n}\n\nexport function modelProves(model: Model, btree: BoolTree): boolean | undefined {\n  const tables = allPossibleTruthTablesOf(model)\n  const result = tables.map(table => resolution(btree, table))\n  if (result.every(it => it)) {\n    return true\n  }\n\n  if (result.every(it => !it)) {\n    return false\n  }\n\n  return undefined\n\n}"]},"metadata":{},"sourceType":"module"}