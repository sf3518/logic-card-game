{"ast":null,"code":"import { State } from \"./state\"; // Premise-related operations\n\nexport const deleteCardAt = index => premise => {\n  const copy = premise.slice();\n  const [card] = copy.splice(index, 1);\n  return State.of(card, copy);\n};\nexport const getCardAt = index => premise => {\n  const card = premise[index];\n  return State.of(card, premise);\n};\nexport const insertCardTo = (card, index) => premise => {\n  const copy = premise.slice();\n  copy.splice(index, 0, card);\n  return State.put(copy);\n};\nexport const swapCardsAt = (index1, index2) => premise => {\n  const copy = premise.slice();\n  [copy[index1], copy[index2]] = [copy[index2], copy[index1]];\n  return State.put(copy);\n};\nexport const onIndex = (index, f) => premises => {\n  const ap = f(premises[index]);\n  return State.of(ap.get, premises.map((p, i) => i == index ? ap.state : p));\n};\nexport const onGoalJson = f => goal => {\n  switch (goal.kind) {\n    case 'paradox':\n    case 'tautology':\n      throw new Error(\"paradox or tautology\");\n\n    default:\n      const fp = f(goal.expr);\n      return State.of(fp.get, {\n        kind: goal.kind,\n        expr: fp.state\n      });\n  }\n}; // Handcard related operations\n\nexport const addHandCard = (card, count = Number.POSITIVE_INFINITY) => hand => {\n  const newHand = [];\n  let added = false;\n  hand.forEach(([c0, count0], i) => {\n    if (!added && c0 == card) {\n      count0 += count;\n      added = true;\n    }\n\n    newHand.push([c0, count0]);\n  });\n\n  if (!added) {\n    newHand.push([card, count]);\n  }\n\n  return State.put(newHand);\n};\nexport const changeCountHandCard = (index, count = Number.POSITIVE_INFINITY) => hand => {\n  if (count == 0) {\n    return deleteHandCard(index)(hand).then(s => State.put(s));\n  }\n\n  const copy = hand.slice();\n  copy[index][1] = count;\n  return State.put(copy);\n};\nexport const getAHandCard = index => hand => {\n  const copy = hand.slice();\n  copy[index][1]--;\n\n  if (copy[index][1] == 0) {\n    return deleteHandCard(index)(hand).getBy(([c, _]) => c);\n  }\n\n  return State.of(copy[index][0], copy);\n};\nexport const deleteHandCard = index => hand => {\n  const copy = hand.slice();\n  const [card] = copy.splice(index, 1);\n  return State.of(card, copy);\n}; // misc utils\n\nexport const moveFromTo = (source, getFromS, dest, putToD) => {\n  const {\n    get,\n    state\n  } = getFromS(source);\n  const d = putToD(get)(dest).state;\n  return [state, d];\n};\nexport const moveWithin = (source, getFrom, putTo) => {\n  const {\n    get,\n    state\n  } = getFrom(source);\n  return putTo(get)(state).state;\n};\nexport const allCards = ['A', 'B', 'C', 'D', '&', '|', '->', '==', '~', '(', ')'];","map":{"version":3,"sources":["/Users/johnny/IC/Computing/DRP/drp48/src/components/editor/editorUtils.ts"],"names":["State","deleteCardAt","index","premise","copy","slice","card","splice","of","getCardAt","insertCardTo","put","swapCardsAt","index1","index2","onIndex","f","premises","ap","get","map","p","i","state","onGoalJson","goal","kind","Error","fp","expr","addHandCard","count","Number","POSITIVE_INFINITY","hand","newHand","added","forEach","c0","count0","push","changeCountHandCard","deleteHandCard","then","s","getAHandCard","getBy","c","_","moveFromTo","source","getFromS","dest","putToD","d","moveWithin","getFrom","putTo","allCards"],"mappings":"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","sourcesContent":["import { Premise, Card, GoalInJSON } from \"../../types\";\nimport { State } from \"./state\";\n\n// Premise-related operations\n\nexport const deleteCardAt = (index: number) => (premise: Premise) : State<Card, Premise> => {\n  const copy = premise.slice()\n  const [card] = copy.splice(index, 1)\n  return State.of(card, copy)\n}\n\nexport const getCardAt = (index: number) => (premise: Premise) : State<Card, Premise> => {\n  const card = premise[index]\n  return State.of(card, premise)\n}\n\nexport const insertCardTo = (card: Card, index: number) => (premise: Premise): State<void, Premise> => {\n  const copy = premise.slice()\n  copy.splice(index, 0, card)\n  return State.put(copy)\n}\n\nexport const swapCardsAt = (index1: number, index2: number) => (premise: Premise): State<void, Premise> => {\n  const copy = premise.slice();\n  [copy[index1], copy[index2]] = [copy[index2], copy[index1]]\n  return State.put(copy)\n}\n\nexport const onIndex = <A, S>(index: number, f: (s: S) => State<A, S>) => (premises: S[]): State<A, S[]> => {\n  const ap = f(premises[index])\n  return State.of(ap.get, premises.map((p, i) => i == index ? ap.state : p))\n}\n\nexport const onGoalJson = <A>(f: (p: Card[]) => State<A, Card[]>) => (goal: GoalInJSON): State<A, GoalInJSON> => {\n  switch (goal.kind) {\n    case 'paradox':\n    case 'tautology': \n      throw new Error(\"paradox or tautology\")\n    default:\n      const fp = f(goal.expr)\n      return State.of(fp.get, { kind: goal.kind, expr: fp.state })\n  }\n}\n\n// Handcard related operations\n\nexport const addHandCard = (card: Card, count: number = Number.POSITIVE_INFINITY) => (hand: [Card, number][])\n    : State<void, [Card, number][]> => {\n  const newHand: [Card, number][] = []\n  let added = false\n  hand.forEach(([c0, count0], i) => {\n    if (!added && c0 == card) {\n      count0 += count\n      added = true\n    }\n    newHand.push([c0, count0])\n  })\n  if (!added) {\n    newHand.push([card, count])\n  }\n  return State.put(newHand)\n}\n\nexport const changeCountHandCard = (index: number, count: number = Number.POSITIVE_INFINITY) => (hand: [Card, number][])\n    : State<void, [Card, number][]> => {\n  if (count == 0) {\n    return deleteHandCard(index)(hand).then(s => State.put(s))\n  }\n  const copy = hand.slice()\n  copy[index][1] = count\n  return State.put(copy)\n}\n\nexport const getAHandCard = (index: number) => (hand: [Card, number][]): State<Card, [Card, number][]> => {\n  const copy = hand.slice()\n  copy[index][1]--\n  if (copy[index][1] == 0) {\n    return deleteHandCard(index)(hand).getBy(([c, _]) => c)\n  }\n  return State.of(copy[index][0], copy)\n}\n\nexport const deleteHandCard = (index: number) => (hand: [Card, number][])\n    : State<[Card, number], [Card, number][]> => {\n  const copy = hand.slice()\n  const [card] = copy.splice(index, 1)\n  return State.of(card, copy)\n}\n\n\n// misc utils\n\nexport const moveFromTo = <C, S, D, _>(source: S, getFromS: (s: S) => State<C, S>, dest: D, putToD: (c: C) => (d: D) => State<_, D>)\n  : [S, D] => {\n    const {get, state} = getFromS(source)\n    const d = putToD(get)(dest).state\n    return [state, d]\n}\n\nexport const moveWithin = <C, S, _>(source: S, getFrom: (s: S) => State<C, S>, putTo: (c: C) => (d: S) => State<_, S>): S => {\n  const {get, state} = getFrom(source)\n  return putTo(get)(state).state\n}\n\nexport const allCards: Card[] = ['A' , 'B' , 'C' , 'D' , '&' , '|' , '->' , '==' , '~' , '(' , ')' ]"]},"metadata":{},"sourceType":"module"}