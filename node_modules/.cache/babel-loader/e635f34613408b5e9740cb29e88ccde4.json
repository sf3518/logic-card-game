{"ast":null,"code":"import _slicedToArray from\"/Users/johnny/IC/Computing/year2/DRP/drp48/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _classCallCheck from\"/Users/johnny/IC/Computing/year2/DRP/drp48/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/johnny/IC/Computing/year2/DRP/drp48/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import{iff,implies,or,and,not}from\"../logicResolver/bools\";export var OperatorTable=/*#__PURE__*/function(){function OperatorTable(binOps,unaryOps){var _this=this;_classCallCheck(this,OperatorTable);this.binOpDic=void 0;this.unaryOps=void 0;this.binOpDic={};binOps.forEach(function(_ref){var _ref2=_slicedToArray(_ref,4),op=_ref2[0],precedence=_ref2[1],fix=_ref2[2],nodeFunc=_ref2[3];_this.binOpDic[op]={precedence:precedence,fixivity:fix,nodeFunc:nodeFunc};});this.unaryOps={};unaryOps.forEach(function(_ref3){var _ref4=_slicedToArray(_ref3,2),op=_ref4[0],nodeFunc=_ref4[1];_this.unaryOps[op]={nodeFunc:nodeFunc};});}_createClass(OperatorTable,[{key:\"isBinaryOperator\",value:function isBinaryOperator(operator){return this.binOpDic.hasOwnProperty(operator);}},{key:\"isUnaryOperator\",value:function isUnaryOperator(operator){return this.unaryOps.hasOwnProperty(operator);}},{key:\"isOperator\",value:function isOperator(card){return this.isUnaryOperator(card)||this.isBinaryOperator(card);}}],[{key:\"defaultTable\",value:function defaultTable(){return new OperatorTable([[\"==\",4,'infixl',iff],[\"->\",3,'infixr',implies],[\"|\",2,'infixl',or],[\"&\",1,'infixl',and]],[[\"~\",not]]);}}]);return OperatorTable;}();","map":{"version":3,"sources":["/Users/johnny/IC/Computing/year2/DRP/drp48/src/server/gameApp/game/operatorTable.ts"],"names":["iff","implies","or","and","not","OperatorTable","binOps","unaryOps","binOpDic","forEach","op","precedence","fix","nodeFunc","fixivity","operator","hasOwnProperty","card","isUnaryOperator","isBinaryOperator"],"mappings":"ieAAA,OAAmBA,GAAnB,CAAwBC,OAAxB,CAAiCC,EAAjC,CAAqCC,GAArC,CAA0CC,GAA1C,KAAqD,wBAArD,CAQA,UAAaC,CAAAA,aAAb,yBAKE,uBAAYC,MAAZ,CAAqEC,QAArE,CAA8G,yDAHrGC,QAGqG,aAFrGD,QAEqG,QAC5G,KAAKC,QAAL,CAAgB,EAAhB,CACAF,MAAM,CAACG,OAAP,CAAe,cAAqC,kCAAnCC,EAAmC,UAA/BC,UAA+B,UAAnBC,GAAmB,UAAdC,QAAc,UAClD,KAAI,CAACL,QAAL,CAAcE,EAAd,EAAoB,CAAEC,UAAU,CAAEA,UAAd,CAA0BG,QAAQ,CAAEF,GAApC,CAAyCC,QAAQ,CAAEA,QAAnD,CAApB,CACD,CAFD,EAGA,KAAKN,QAAL,CAAgB,EAAhB,CACAA,QAAQ,CAACE,OAAT,CAAiB,eAAoB,mCAAlBC,EAAkB,UAAdG,QAAc,UACnC,KAAI,CAACN,QAAL,CAAcG,EAAd,EAAoB,CAAEG,QAAQ,CAAEA,QAAZ,CAApB,CACD,CAFD,EAGD,CAdH,oFA4BmBE,QA5BnB,CA4B4C,CACxC,MAAO,MAAKP,QAAL,CAAcQ,cAAd,CAA6BD,QAA7B,CAAP,CACD,CA9BH,wDAgCkBA,QAhClB,CAgC2C,CACvC,MAAO,MAAKR,QAAL,CAAcS,cAAd,CAA6BD,QAA7B,CAAP,CACD,CAlCH,8CAoCaE,IApCb,CAoCkC,CAC9B,MAAO,MAAKC,eAAL,CAAqBD,IAArB,GAA8B,KAAKE,gBAAL,CAAsBF,IAAtB,CAArC,CACD,CAtCH,qDAgBuC,CACnC,MAAO,IAAIZ,CAAAA,aAAJ,CACL,CACE,CAAC,IAAD,CAAO,CAAP,CAAU,QAAV,CAAoBL,GAApB,CADF,CAEE,CAAC,IAAD,CAAO,CAAP,CAAU,QAAV,CAAoBC,OAApB,CAFF,CAGE,CAAC,GAAD,CAAM,CAAN,CAAS,QAAT,CAAmBC,EAAnB,CAHF,CAIE,CAAC,GAAD,CAAM,CAAN,CAAS,QAAT,CAAmBC,GAAnB,CAJF,CADK,CAOL,CAAC,CAAC,GAAD,CAAMC,GAAN,CAAD,CAPK,CAAP,CASD,CA1BH","sourcesContent":["import { BoolTree, iff, implies, or, and, not } from \"../logicResolver/bools\"\nimport { Card } from \"../../../types\"\n\nexport type Fixivity = 'infixl' | 'infixr'\n\nexport type BinaryConstructor = (b1: BoolTree, b2: BoolTree) => BoolTree\nexport type UnaryConstructor = (b: BoolTree) => BoolTree\n\nexport class OperatorTable {\n\n  readonly binOpDic: { [operator: string]: { precedence: number, fixivity: Fixivity, nodeFunc: BinaryConstructor } }\n  readonly unaryOps: { [operator: string]: { nodeFunc: UnaryConstructor } }\n\n  constructor(binOps: [string, number, Fixivity, BinaryConstructor][], unaryOps: [string, UnaryConstructor][] ) {\n    this.binOpDic = {}\n    binOps.forEach(([op, precedence, fix, nodeFunc]) => {\n      this.binOpDic[op] = { precedence: precedence, fixivity: fix, nodeFunc: nodeFunc }\n    })\n    this.unaryOps = {}\n    unaryOps.forEach(([op, nodeFunc]) => {\n      this.unaryOps[op] = { nodeFunc: nodeFunc }\n    })\n  }\n\n  static defaultTable(): OperatorTable {\n    return new OperatorTable(\n      [\n        [\"==\", 4, 'infixl', iff],\n        [\"->\", 3, 'infixr', implies],\n        [\"|\", 2, 'infixl', or],\n        [\"&\", 1, 'infixl', and],\n      ],\n      [[\"~\", not]]\n    )\n  }\n\n  isBinaryOperator(operator: Card): boolean {\n    return this.binOpDic.hasOwnProperty(operator)\n  }\n\n  isUnaryOperator(operator: Card): boolean {\n    return this.unaryOps.hasOwnProperty(operator)\n  }\n\n  isOperator(card: Card): boolean {\n    return this.isUnaryOperator(card) || this.isBinaryOperator(card)\n  }\n}"]},"metadata":{},"sourceType":"module"}