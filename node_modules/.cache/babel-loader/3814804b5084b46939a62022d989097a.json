{"ast":null,"code":"import { variable, UnaryOperator, BinaryOperator } from \"./bools\";\nexport class PlainResolver {\n  constructor(variables = [\"A\", \"B\", \"C\", \"D\"]) {\n    this.variables = void 0;\n    this.variables = variables;\n  }\n\n  generateModel(trees) {\n    let provens = this.variables.slice();\n    let disprovens = this.variables.slice();\n    let isParadox = true;\n    generateTruthTables(this.variables).forEach(table => {\n      if (resolutionAll(trees, table)) {\n        provens = provens.filter(x => table[x]);\n        disprovens = disprovens.filter(x => !table[x]);\n        isParadox = false;\n      }\n    });\n\n    if (isParadox) {\n      return undefined;\n    }\n\n    return {\n      positives: new Set(provens),\n      negatives: new Set(disprovens),\n      unknowns: new Set(this.variables.filter(x => !provens.includes(x) && !disprovens.includes(x)))\n    };\n  }\n\n  canBeProvenBy(trees, goalTree, expected) {\n    let cases = [];\n    generateTruthTables(this.variables).forEach(table => {\n      const all = resolutionAll(trees, table);\n      const pass = resolution(goalTree, table);\n\n      if (all) {\n        cases.push(pass);\n      }\n    });\n    const isAllTrue = cases.reduce((a, b) => a && b);\n    const isAllFalse = !cases.reduce((a, b) => a || b);\n\n    switch (expected) {\n      case true:\n        return isAllTrue;\n\n      case false:\n        return isAllFalse;\n\n      case undefined:\n        return !isAllTrue && !isAllFalse;\n    }\n  }\n\n  isEquivalentTo(trees, goalTree) {\n    const tables = generateTruthTables(this.variables);\n\n    for (let i = 0; i < tables.length; i++) {\n      if (resolutionAll(trees, tables[i]) != resolution(goalTree, tables[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nfunction resolutionAll(trees, table) {\n  return trees.map(tree => resolution(tree, table)).reduce((a, b) => a && b);\n}\n\nfunction resolution(tree, table) {\n  switch (tree.kind) {\n    case \"constant\":\n      return tree.value;\n\n    case \"variable\":\n      return table[tree.variable];\n\n    case \"unary\":\n      return UnaryOperator.apply(tree.operator, resolution(tree.child, table));\n\n    case \"binary\":\n      return BinaryOperator.apply(tree.operator, resolution(tree.left, table), resolution(tree.right, table));\n  }\n}\n\nfunction bitVectorToTable(bitVector, variables) {\n  let table = {};\n\n  for (let i = 0; i < variables.length; i++, bitVector >>= 1) {\n    let set = 1 & bitVector;\n    table[variables[i]] = set != 0;\n  }\n\n  return table;\n}\n\nfunction generateTruthTables(variables) {\n  return Array.from(Array(2 ** variables.length).keys()).map(vector => bitVectorToTable(vector, variables));\n}\n\nexport function allPossibleTruthTablesOf(model) {\n  const tables = [];\n  const unknowns = [];\n  model.unknowns.forEach(e => unknowns.push(e));\n  Array.from(Array(2 ** unknowns.length).keys()).forEach(vector => {\n    const table = {};\n    model.positives.forEach(p => table[p] = true);\n    model.negatives.forEach(n => table[n] = false);\n\n    for (let i = 0; i < unknowns.length; i++, vector >>= 1) {\n      let set = 1 & vector;\n      table[unknowns[i]] = set != 0;\n    }\n\n    tables.push(table);\n  });\n  return tables;\n}\nexport function modelProves(model, btree) {\n  const tables = allPossibleTruthTablesOf(model);\n  const result = tables.map(table => resolution(btree, table));\n\n  if (result.every(it => it)) {\n    return true;\n  }\n\n  if (result.every(it => !it)) {\n    return false;\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["/Users/johnny/IC/Computing/DRP/drp48/src/server/gameApp/logicResolver/plainResolver.ts"],"names":["variable","UnaryOperator","BinaryOperator","PlainResolver","constructor","variables","generateModel","trees","provens","slice","disprovens","isParadox","generateTruthTables","forEach","table","resolutionAll","filter","x","undefined","positives","Set","negatives","unknowns","includes","canBeProvenBy","goalTree","expected","cases","all","pass","resolution","push","isAllTrue","reduce","a","b","isAllFalse","isEquivalentTo","tables","i","length","map","tree","kind","value","apply","operator","child","left","right","bitVectorToTable","bitVector","set","Array","from","keys","vector","allPossibleTruthTablesOf","model","e","p","n","modelProves","btree","result","every","it"],"mappings":"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","sourcesContent":["import { BoolTree, variable, UnaryOperator, BinaryOperator, and, implies } from \"./bools\"\nimport { Resolver, Model } from \"./resolver\"\n\nexport type TruthTable = { [variable: string]: boolean }\nexport type TruthTableResults = [TruthTable, boolean]\n\ntype BitVector = number\n\nexport class PlainResolver implements Resolver {\n  variables: string[]\n  constructor(variables: string[] = [\"A\", \"B\", \"C\", \"D\"]) {\n    this.variables = variables\n  }\n  generateModel(trees: BoolTree[]): Model | undefined {\n    let provens: string[] = this.variables.slice()\n    let disprovens: string[] = this.variables.slice()\n    let isParadox = true\n    generateTruthTables(this.variables).forEach(table => {\n      if (resolutionAll(trees, table)) {\n        provens = provens.filter(x => table[x])\n        disprovens = disprovens.filter(x => !table[x])\n        isParadox = false\n      }\n    })\n    if (isParadox) {\n      return undefined\n    }\n    return { \n      positives: new Set(provens), \n      negatives: new Set(disprovens), \n      unknowns: new Set(this.variables.filter(x => !provens.includes(x) && !disprovens.includes(x)))\n    }\n  }\n\n  canBeProvenBy(trees: BoolTree[], goalTree: BoolTree, expected: boolean | undefined): boolean {\n    let cases: boolean[] = []\n    generateTruthTables(this.variables).forEach(table => {\n      const all = resolutionAll(trees, table)\n      const pass = resolution(goalTree, table)\n      if (all) {\n        cases.push(pass) \n      }\n    })\n    const isAllTrue = cases.reduce((a, b) => a && b)\n    const isAllFalse = !cases.reduce((a, b) => a || b)\n    switch(expected) {\n      case true: return isAllTrue\n      case false: return isAllFalse\n      case undefined: return !isAllTrue && !isAllFalse\n    }\n  }\n\n  isEquivalentTo(trees: BoolTree[], goalTree: BoolTree): boolean {\n    const tables = generateTruthTables(this.variables)\n    for (let i = 0; i < tables.length; i++) {\n      if (resolutionAll(trees, tables[i]) != resolution(goalTree, tables[i])) {\n        return false\n      }\n    }\n    return true\n  }\n\n}\n\n\n\nfunction resolutionAll(trees: BoolTree[], table: TruthTable): boolean {\n  return trees.map(tree => resolution(tree, table)).reduce((a, b) => a && b)\n}\n\nfunction resolution(tree: BoolTree, table: TruthTable): boolean {\n  switch(tree.kind) {\n    case \"constant\": \n      return tree.value\n    case \"variable\":\n      return table[tree.variable]\n    case \"unary\":\n      return UnaryOperator.apply(tree.operator, resolution(tree.child, table))\n    case \"binary\":\n      return BinaryOperator.apply(tree.operator, resolution(tree.left, table), resolution(tree.right, table))\n  }\n}\n\nfunction bitVectorToTable(bitVector: BitVector, variables: string[]): TruthTable {\n  let table: TruthTable = {}\n  for(let i = 0; i < variables.length; i++, bitVector >>= 1) {\n    let set = 1 & bitVector\n    table[variables[i]] = set != 0\n  }\n  return table\n}\n\nfunction generateTruthTables(variables: string[]): TruthTable[] {\n  return Array.from(Array(2 ** variables.length).keys())\n    .map(vector => bitVectorToTable(vector, variables))\n}\n\nexport function allPossibleTruthTablesOf(model: Model): TruthTable[] {\n  const tables: TruthTable[] = []\n  const unknowns: string[] = []\n  model.unknowns.forEach(e => unknowns.push(e))\n  Array.from(Array(2 ** unknowns.length).keys()).forEach(vector => {\n    const table: TruthTable = {}\n    model.positives.forEach(p => table[p] = true)\n    model.negatives.forEach(n => table[n] = false)\n    for(let i = 0; i < unknowns.length; i++, vector >>= 1) {\n      let set = 1 & vector\n      table[unknowns[i]] = set != 0\n    }\n    tables.push(table)\n  })\n  return tables\n}\n\nexport function modelProves(model: Model, btree: BoolTree): boolean | undefined {\n  const tables = allPossibleTruthTablesOf(model)\n  const result = tables.map(table => resolution(btree, table))\n  if (result.every(it => it)) {\n    return true\n  }\n\n  if (result.every(it => !it)) {\n    return false\n  }\n\n  return undefined\n\n}"]},"metadata":{},"sourceType":"module"}