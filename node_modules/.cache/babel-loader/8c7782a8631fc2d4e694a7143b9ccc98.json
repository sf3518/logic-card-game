{"ast":null,"code":"import { variable, top } from \"../logicResolver/bools\";\nimport { OperatorTable } from \"./operatorTable\";\n// export function genTruthTableInString(vars: Card[], premises: Premise[]): TruthTableInString {\n//   const trees = premises.map(p => parsePremiseSafe(p, vars))\n//   if (trees.includes(undefined)) {\n//     const table: TruthTableInString = {}\n//     vars.forEach(v => table[v] = \"-\")\n//     return table\n//   } \n//   return genTruthTableInStringForBTree(vars, trees as BoolTree[])\n// }\nexport function parsePremiseSafe(premise, variables, operatorTable = OperatorTable.defaultTable()) {\n  try {\n    return parsePremise(premise, variables, operatorTable);\n  } catch (e) {\n    return undefined;\n  }\n}\nexport function parsePremise(premise, variables, operatorTable = OperatorTable.defaultTable()) {\n  if (premise.length == 0) {\n    return top();\n  }\n\n  const isParenCard = c => c == \")\" || c == \"(\";\n\n  premise.forEach(card => {\n    if (!variables.includes(card) && !operatorTable.isOperator(card) && !isParenCard(card)) {\n      throw Error(\"Unexpected card: \" + card);\n    }\n  });\n  return parsePremiseSection(premise, operatorTable, 0, premise.length - 1);\n} // Parse the premise with in a given section suggested by @start and \n// @end (both inclusive), with the provided OperatorTable.\n// Returns the BoolTree if the Parsing is successful.\n\nfunction parsePremiseSection(premise, operatorTable, start, end) {\n  if (start > end) {\n    throw new Error(\"premise parse error\");\n  }\n\n  let pc = undefined;\n  let parenStack = 0; // scan through the given section to determine pc\n\n  for (let i = start; i <= end; i++) {\n    let card = premise[i];\n\n    switch (card) {\n      case \"(\":\n        parenStack += 1;\n        break;\n\n      case \")\":\n        parenStack -= 1; // check if parens are unmatched\n\n        if (parenStack < 0) {\n          throw new Error(\"unmatched parentheses\");\n        }\n\n        break;\n\n      default:\n        if (parenStack == 0 && operatorTable.isBinaryOperator(card)) {\n          let {\n            precedence: p,\n            fixivity: fix,\n            nodeFunc: nodeFunc\n          } = operatorTable.binOpDic[card];\n\n          if (pc == undefined || pc.precedence < p || pc.precedence == p && pc.fixivity == 'infixl') {\n            // update pc \n            pc = {\n              card: card,\n              index: i,\n              precedence: p,\n              fixivity: fix,\n              constructor: nodeFunc\n            };\n          }\n        }\n\n        break;\n    }\n  }\n\n  if (parenStack != 0) {\n    throw new Error(\"unmatched parentheses\");\n  } // If principle connector exists \n  // parse lhs and rhs of the pc within this section\n  // return constructor(lhs, rhs)\n\n\n  if (pc != undefined) {\n    const left = parsePremiseSection(premise, operatorTable, start, pc.index - 1);\n    const right = parsePremiseSection(premise, operatorTable, pc.index + 1, end);\n    return pc.constructor(left, right);\n  } // If the section given is covered by a pair of parentheses\n  // Parse the section within that pair of parentheses\n\n\n  if (premise[start] == \"(\" && premise[end] == \")\") {\n    return parsePremiseSection(premise, operatorTable, start + 1, end - 1);\n  } // If the first card in this section is a unary operator card\n\n\n  const head = premise[start];\n\n  if (operatorTable.isUnaryOperator(head)) {\n    const child = parsePremiseSection(premise, operatorTable, start + 1, end);\n    return operatorTable.unaryOps[head].nodeFunc(child);\n  } // If the section only contain 1 card, and that card is a variable\n\n\n  if (start == end) {\n    return variable(head);\n  } // Otherwise, there is an error\n\n\n  throw new Error(\"parse error\");\n}","map":{"version":3,"sources":["/Users/johnny/IC/Computing/DRP/drp48/src/server/gameApp/game/premise.ts"],"names":["variable","top","OperatorTable","parsePremiseSafe","premise","variables","operatorTable","defaultTable","parsePremise","e","undefined","length","isParenCard","c","forEach","card","includes","isOperator","Error","parsePremiseSection","start","end","pc","parenStack","i","isBinaryOperator","precedence","p","fixivity","fix","nodeFunc","binOpDic","index","constructor","left","right","head","isUnaryOperator","child","unaryOps"],"mappings":"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","sourcesContent":["import { Card, Premise, TruthTableInString } from \"../../../types\"\nimport { BoolTree, variable, top } from \"../logicResolver/bools\"\nimport { OperatorTable, Fixivity, BinaryConstructor } from \"./operatorTable\"\nimport { PlainResolver } from \"../logicResolver/plainResolver\"\n\n// export function genTruthTableInString(vars: Card[], premises: Premise[]): TruthTableInString {\n//   const trees = premises.map(p => parsePremiseSafe(p, vars))\n//   if (trees.includes(undefined)) {\n//     const table: TruthTableInString = {}\n//     vars.forEach(v => table[v] = \"-\")\n//     return table\n//   } \n//   return genTruthTableInStringForBTree(vars, trees as BoolTree[])\n// }\n\nexport function parsePremiseSafe(\n  premise: Premise,\n  variables: Card[], \n  operatorTable: OperatorTable = OperatorTable.defaultTable()\n): BoolTree | undefined {\n  try {\n    return  parsePremise(premise, variables, operatorTable)\n  } catch(e) {\n    return undefined\n  }\n}\n\nexport function parsePremise(\n  premise: Premise,\n  variables: Card[], \n  operatorTable: OperatorTable = OperatorTable.defaultTable()\n): BoolTree | never {\n  if (premise.length == 0) {\n    return top()\n  }\n  const isParenCard = (c: Card) => c == \")\" || c == \"(\"\n  premise.forEach(card => {\n    if (!variables.includes(card) \n    && !operatorTable.isOperator(card) \n    && !isParenCard(card)) {\n      throw Error(\"Unexpected card: \" + card)\n    }\n  })\n  return parsePremiseSection(premise, operatorTable, 0, premise.length - 1)\n}\n\n// Parse the premise with in a given section suggested by @start and \n// @end (both inclusive), with the provided OperatorTable.\n// Returns the BoolTree if the Parsing is successful.\nfunction parsePremiseSection(\n  premise: Premise, \n  operatorTable: OperatorTable, \n  start: number, \n  end: number\n): BoolTree | never {\n\n  if (start > end) {\n    throw new Error(\"premise parse error\")\n  }\n\n  type PcInfo = { \n    card: Card, \n    index: number, \n    precedence: number, \n    fixivity: Fixivity, \n    constructor: BinaryConstructor \n  }\n\n  let pc: PcInfo | undefined = undefined\n  let parenStack = 0\n  \n  // scan through the given section to determine pc\n  for (let i = start; i <= end; i++) {\n    let card = premise[i]\n    switch(card) {\n      case \"(\":\n        parenStack += 1\n        break\n      case \")\":\n        parenStack -= 1\n        // check if parens are unmatched\n        if (parenStack < 0) {\n          throw new Error(\"unmatched parentheses\")\n        }\n        break\n      default:\n        if (parenStack == 0 && operatorTable.isBinaryOperator(card)) {\n          let { precedence: p, fixivity: fix, nodeFunc: nodeFunc } = operatorTable.binOpDic[card] \n          if (pc == undefined\n          || pc.precedence < p \n          || pc.precedence == p && pc.fixivity == 'infixl') {\n            // update pc \n            pc = {\n              card: card,\n              index: i,\n              precedence: p,\n              fixivity: fix,\n              constructor: nodeFunc\n            }\n          }\n        }\n        break\n    }\n  }\n\n  if (parenStack != 0) {\n    throw new Error(\"unmatched parentheses\")\n  }\n\n  // If principle connector exists \n  // parse lhs and rhs of the pc within this section\n  // return constructor(lhs, rhs)\n  if (pc != undefined) {\n    const left = parsePremiseSection(premise, operatorTable, start, pc.index - 1)\n    const right = parsePremiseSection(premise, operatorTable, pc.index + 1, end)\n    return pc.constructor(left, right)\n  }\n  \n  // If the section given is covered by a pair of parentheses\n  // Parse the section within that pair of parentheses\n  if (premise[start] == \"(\" && premise[end] == \")\") {\n    return parsePremiseSection(premise, operatorTable, start + 1, end - 1)\n  } \n\n  // If the first card in this section is a unary operator card\n  const head = premise[start]\n  if (operatorTable.isUnaryOperator(head)) {\n    const child = parsePremiseSection(premise, operatorTable, start + 1, end)\n    return operatorTable.unaryOps[head].nodeFunc(child)\n  }\n\n  // If the section only contain 1 card, and that card is a variable\n  if (start == end) {\n    return variable(head)\n  }\n\n  // Otherwise, there is an error\n  throw new Error(\"parse error\")\n\n}"]},"metadata":{},"sourceType":"module"}