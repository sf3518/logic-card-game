{"ast":null,"code":"import { variable, UnaryOperator, BinaryOperator, top } from \"./bools\";\nexport class PlainResolver {\n  constructor(variables = [\"A\", \"B\", \"C\", \"D\"]) {\n    this.variables = void 0;\n    this.variables = variables;\n  }\n\n  generateModel(trees) {\n    let provens = this.variables.slice();\n    let disprovens = this.variables.slice();\n    let isParadox = true;\n    generateTruthTables(this.variables).forEach(table => {\n      if (resolutionAll(trees, table)) {\n        provens = provens.filter(x => table[x]);\n        disprovens = disprovens.filter(x => !table[x]);\n        isParadox = false;\n      }\n    });\n\n    if (isParadox) {\n      return undefined;\n    }\n\n    return {\n      positives: new Set(provens),\n      negatives: new Set(disprovens),\n      unknowns: new Set(this.variables.filter(x => !provens.includes(x) && !disprovens.includes(x)))\n    };\n  }\n\n  canBeProvenBy(trees, goalTree, expected) {\n    let cases = [];\n    generateTruthTables(this.variables).forEach(table => {\n      const all = resolutionAll(trees, table);\n      const pass = resolution(goalTree, table);\n\n      if (all) {\n        cases.push(pass);\n      }\n    });\n    const isAllTrue = cases.reduce((a, b) => a && b);\n    const isAllFalse = !cases.reduce((a, b) => a || b);\n\n    switch (expected) {\n      case true:\n        return isAllTrue;\n\n      case false:\n        return isAllFalse;\n\n      case undefined:\n        return !isAllTrue && !isAllFalse;\n    }\n  }\n\n  isEquivalentTo(trees, goalTree) {\n    const tables = generateTruthTables(this.variables);\n\n    for (let i = 0; i < tables.length; i++) {\n      if (resolutionAll(trees, tables[i]) != resolution(goalTree, tables[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  isAlwaysTrue(trees) {\n    return this.isEquivalentTo(trees, top());\n  }\n\n}\n\nfunction resolutionAll(trees, table) {\n  if (trees.length == 0) {\n    return true;\n  }\n\n  return trees.map(tree => resolution(tree, table)).reduce((a, b) => a && b);\n}\n\nfunction resolution(tree, table) {\n  switch (tree.kind) {\n    case \"constant\":\n      return tree.value;\n\n    case \"variable\":\n      return table[tree.variable];\n\n    case \"unary\":\n      return UnaryOperator.apply(tree.operator, resolution(tree.child, table));\n\n    case \"binary\":\n      return BinaryOperator.apply(tree.operator, resolution(tree.left, table), resolution(tree.right, table));\n  }\n}\n\nfunction bitVectorToTable(bitVector, variables) {\n  let table = {};\n\n  for (let i = 0; i < variables.length; i++, bitVector >>= 1) {\n    let set = 1 & bitVector;\n    table[variables[i]] = set != 0;\n  }\n\n  return table;\n}\n\nfunction generateTruthTables(variables) {\n  return Array.from(Array(2 ** variables.length).keys()).map(vector => bitVectorToTable(vector, variables));\n}\n\nexport function allPossibleTruthTablesOf(model) {\n  const tables = [];\n  const unknowns = [];\n  model.unknowns.forEach(e => unknowns.push(e));\n  Array.from(Array(2 ** unknowns.length).keys()).forEach(vector => {\n    const table = {};\n    model.positives.forEach(p => table[p] = true);\n    model.negatives.forEach(n => table[n] = false);\n\n    for (let i = 0; i < unknowns.length; i++, vector >>= 1) {\n      let set = 1 & vector;\n      table[unknowns[i]] = set != 0;\n    }\n\n    tables.push(table);\n  });\n  return tables;\n}\nexport function genTruthTableInStringForBTrees(vars, trees) {\n  const body = [];\n\n  const translateBool = b => b ? \"⊤\" : \"⊥\";\n\n  const isValid = !trees.includes(undefined);\n  generateTruthTables(vars).forEach(table => {\n    const row = [];\n    vars.forEach(v => row.push(translateBool(table[v])));\n    row.push(isValid ? translateBool(resolutionAll(trees, table)) : \"?\");\n    body.push(row);\n  });\n  return {\n    headers: vars.concat(\"val\"),\n    body: body\n  };\n}","map":{"version":3,"sources":["/Users/johnny/IC/Computing/DRP/drp48/src/server/gameApp/logicResolver/plainResolver.ts"],"names":["variable","UnaryOperator","BinaryOperator","top","PlainResolver","constructor","variables","generateModel","trees","provens","slice","disprovens","isParadox","generateTruthTables","forEach","table","resolutionAll","filter","x","undefined","positives","Set","negatives","unknowns","includes","canBeProvenBy","goalTree","expected","cases","all","pass","resolution","push","isAllTrue","reduce","a","b","isAllFalse","isEquivalentTo","tables","i","length","isAlwaysTrue","map","tree","kind","value","apply","operator","child","left","right","bitVectorToTable","bitVector","set","Array","from","keys","vector","allPossibleTruthTablesOf","model","e","p","n","genTruthTableInStringForBTrees","vars","body","translateBool","isValid","row","v","headers","concat"],"mappings":"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","sourcesContent":["import { BoolTree, variable, UnaryOperator, BinaryOperator, and, implies, top } from \"./bools\"\nimport { Resolver, Model } from \"./resolver\"\nimport { Card, TruthTableInString } from \"../../../types\"\n\nexport type TruthTable = { [variable: string]: boolean }\nexport type TruthTableResults = [TruthTable, boolean]\n\ntype BitVector = number\n\nexport class PlainResolver implements Resolver {\n  variables: string[]\n  constructor(variables: string[] = [\"A\", \"B\", \"C\", \"D\"]) {\n    this.variables = variables\n  }\n  generateModel(trees: BoolTree[]): Model | undefined {\n    let provens: string[] = this.variables.slice()\n    let disprovens: string[] = this.variables.slice()\n    let isParadox = true\n    generateTruthTables(this.variables).forEach(table => {\n      if (resolutionAll(trees, table)) {\n        provens = provens.filter(x => table[x])\n        disprovens = disprovens.filter(x => !table[x])\n        isParadox = false\n      }\n    })\n    if (isParadox) {\n      return undefined\n    }\n    return { \n      positives: new Set(provens), \n      negatives: new Set(disprovens), \n      unknowns: new Set(this.variables.filter(x => !provens.includes(x) && !disprovens.includes(x)))\n    }\n  }\n\n  canBeProvenBy(trees: BoolTree[], goalTree: BoolTree, expected: boolean | undefined): boolean {\n    let cases: boolean[] = []\n    generateTruthTables(this.variables).forEach(table => {\n      const all = resolutionAll(trees, table)\n      const pass = resolution(goalTree, table)\n      if (all) {\n        cases.push(pass) \n      }\n    })\n    const isAllTrue = cases.reduce((a, b) => a && b)\n    const isAllFalse = !cases.reduce((a, b) => a || b)\n    switch(expected) {\n      case true: return isAllTrue\n      case false: return isAllFalse\n      case undefined: return !isAllTrue && !isAllFalse\n    }\n  }\n\n  isEquivalentTo(trees: BoolTree[], goalTree: BoolTree): boolean {\n    const tables = generateTruthTables(this.variables)\n    for (let i = 0; i < tables.length; i++) {\n      if (resolutionAll(trees, tables[i]) != resolution(goalTree, tables[i])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isAlwaysTrue(trees: BoolTree[]): boolean {\n    return this.isEquivalentTo(trees, top())\n  }\n\n}\n\n\n\nfunction resolutionAll(trees: BoolTree[], table: TruthTable): boolean {\n  if (trees.length == 0) {\n    return true\n  }\n  return trees.map(tree => resolution(tree, table)).reduce((a, b) => a && b)\n}\n\nfunction resolution(tree: BoolTree, table: TruthTable): boolean {\n  switch(tree.kind) {\n    case \"constant\": \n      return tree.value\n    case \"variable\":\n      return table[tree.variable]\n    case \"unary\":\n      return UnaryOperator.apply(tree.operator, resolution(tree.child, table))\n    case \"binary\":\n      return BinaryOperator.apply(tree.operator, resolution(tree.left, table), resolution(tree.right, table))\n  }\n}\n\nfunction bitVectorToTable(bitVector: BitVector, variables: string[]): TruthTable {\n  let table: TruthTable = {}\n  for(let i = 0; i < variables.length; i++, bitVector >>= 1) {\n    let set = 1 & bitVector\n    table[variables[i]] = set != 0\n  }\n  return table\n}\n\nfunction generateTruthTables(variables: string[]): TruthTable[] {\n  return Array.from(Array(2 ** variables.length).keys())\n    .map(vector => bitVectorToTable(vector, variables))\n}\n\nexport function allPossibleTruthTablesOf(model: Model): TruthTable[] {\n  const tables: TruthTable[] = []\n  const unknowns: string[] = []\n  model.unknowns.forEach(e => unknowns.push(e))\n  Array.from(Array(2 ** unknowns.length).keys()).forEach(vector => {\n    const table: TruthTable = {}\n    model.positives.forEach(p => table[p] = true)\n    model.negatives.forEach(n => table[n] = false)\n    for(let i = 0; i < unknowns.length; i++, vector >>= 1) {\n      let set = 1 & vector\n      table[unknowns[i]] = set != 0\n    }\n    tables.push(table)\n  })\n  return tables\n}\n\nexport function genTruthTableInStringForBTrees(vars: Card[], trees: (BoolTree | undefined)[]): TruthTableInString {\n  const body: string[][] = []\n  const translateBool = (b: boolean) => b ? \"⊤\" : \"⊥\"\n  const isValid = !trees.includes(undefined)\n  generateTruthTables(vars).forEach(table => {\n    const row: string[] = []\n    vars.forEach(v => row.push(translateBool(table[v])))\n    row.push(isValid ? translateBool(resolutionAll(trees as BoolTree[], table)) : \"?\")\n    body.push(row)\n  })\n  return { headers: (vars as string[]).concat(\"val\"), body: body }\n}"]},"metadata":{},"sourceType":"module"}