{"ast":null,"code":"import _toConsumableArray from\"/Users/johnny/IC/Computing/year2/DRP/drp48/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"/Users/johnny/IC/Computing/year2/DRP/drp48/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{PlainResolver}from'../server/gameApp/logicResolver/plainResolver';import{parsePremise}from'../server/gameApp/game/premise';import{OperatorTable}from'../server/gameApp/game/operatorTable';export function doActionToView(view,action){switch(action.kind){case'play-card':var _action$premiseIndice=_slicedToArray(action.premiseIndices,2),pid=_action$premiseIndice[0],ipid=_action$premiseIndice[1];return playHandCardTo(view,action.handIndex,pid,ipid);case'discard':return discardToPile(view,action.handIndex);case'ergo':return view;case'swap-hand':return swapHandCards(view,action.handIndex1,action.handIndex2);}}export function playHandCardTo(view,handCardIndex,premiseIndex,inPremisePosition){var _view$handCardWithCou=_slicedToArray(view.handCardWithCount[handCardIndex],2),card=_view$handCardWithCou[0],count=_view$handCardWithCou[1];var nextHandCards=view.handCardWithCount.slice();var _view$premises$premis=_slicedToArray(view.premises[premiseIndex],2),premise=_view$premises$premis[0],isLocked=_view$premises$premis[1];var nextPremise=[premise.slice(),isLocked];var nextPremises=view.premises.slice();if(count==1){nextHandCards.splice(handCardIndex,1);}else{nextHandCards[handCardIndex]=[card,count-1];}nextPremise[0].splice(inPremisePosition,0,card);nextPremises.splice(premiseIndex,1,nextPremise);console.log(view.premises[premiseIndex].slice());console.log(nextPremise);return{playerVar:view.playerVar,handCardWithCount:nextHandCards,discardPile:_toConsumableArray(view.discardPile),premises:nextPremises,deckCount:view.deckCount,goals:view.goals};}export function discardToPile(view,handCardIndex){var _view$handCardWithCou2=_slicedToArray(view.handCardWithCount[handCardIndex],2),card=_view$handCardWithCou2[0],count=_view$handCardWithCou2[1];var nextHandCards=_toConsumableArray(view.handCardWithCount);var nextDiscardPile=view.discardPile.slice();if(count==1){nextHandCards.splice(handCardIndex,1);nextDiscardPile.push(card);}else{nextHandCards[handCardIndex]=[card,count-1];}return{playerVar:view.playerVar,handCardWithCount:nextHandCards,discardPile:nextDiscardPile,premises:view.premises.map(function(_ref){var _ref2=_slicedToArray(_ref,2),premise=_ref2[0],isLocked=_ref2[1];return[premise.slice(),isLocked];}),deckCount:view.deckCount,goals:view.goals};}export function swapHandCards(view,index1,index2){var newHand=view.handCardWithCount.slice();var _ref3=[newHand[index2],newHand[index1]];newHand[index1]=_ref3[0];newHand[index2]=_ref3[1];return{playerVar:view.playerVar,handCardWithCount:newHand,discardPile:_toConsumableArray(view.discardPile),premises:view.premises,deckCount:view.deckCount,goals:view.goals};}export function getGoalStates(view){return evalSuccess(view.premises.map(function(_ref4){var _ref5=_slicedToArray(_ref4,2),p=_ref5[0],_=_ref5[1];return p;}),view.goals);}export function evalSuccess(premises,goals){var btrees=[];try{premises.forEach(function(premise){var btree=parsePremise(premise,[\"A\",\"B\",\"C\",\"D\"],OperatorTable.defaultTable());btrees.push(btree);});}catch(e){return goals.map(function(_){return false;});}var resolver=new PlainResolver([\"A\",\"B\",\"C\",\"D\"]);var model=resolver.generateModel(btrees);if(model==undefined){return goals.map(function(g){var _ref6;return(_ref6=(g===null||g===void 0?void 0:g.kind)=='paradox')!==null&&_ref6!==void 0?_ref6:false;});}return goals.map(function(goal){console.log(goal);if(goal){switch(goal.kind){case'prove':return resolver.canBeProvenBy(btrees,goal.boolTree,true);case'disprove':return resolver.canBeProvenBy(btrees,goal.boolTree,false);case'unknown':return resolver.canBeProvenBy(btrees,goal.boolTree,undefined);case'equivalent':return resolver.isEquivalentTo(btrees,goal.boolTree);case'tautology':return resolver.isAlwaysTrue(btrees);case'paradox':return false;}}return false;});}export function fixInfinityNumber(view){view.handCardWithCount=view.handCardWithCount.map(function(_ref7){var _ref8=_slicedToArray(_ref7,2),card=_ref8[0],num=_ref8[1];return[card,num?num:Number.POSITIVE_INFINITY];});return view;}","map":{"version":3,"sources":["/Users/johnny/IC/Computing/year2/DRP/drp48/src/game/views.ts"],"names":["PlainResolver","parsePremise","OperatorTable","doActionToView","view","action","kind","premiseIndices","pid","ipid","playHandCardTo","handIndex","discardToPile","swapHandCards","handIndex1","handIndex2","handCardIndex","premiseIndex","inPremisePosition","handCardWithCount","card","count","nextHandCards","slice","premises","premise","isLocked","nextPremise","nextPremises","splice","console","log","playerVar","discardPile","deckCount","goals","nextDiscardPile","push","map","index1","index2","newHand","getGoalStates","evalSuccess","p","_","btrees","forEach","btree","defaultTable","e","resolver","model","generateModel","undefined","g","goal","canBeProvenBy","boolTree","isEquivalentTo","isAlwaysTrue","fixInfinityNumber","num","Number","POSITIVE_INFINITY"],"mappings":"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","sourcesContent":["import { GameView, GameAction, Card, Premise, Goal } from '../types'\nimport { BoolTree } from '../server/gameApp/logicResolver/bools'\nimport { allPossibleTruthTablesOf, PlainResolver } from '../server/gameApp/logicResolver/plainResolver'\nimport { parsePremise } from '../server/gameApp/game/premise'\nimport { Model } from '../server/gameApp/logicResolver/resolver'\nimport { OperatorTable } from '../server/gameApp/game/operatorTable'\n\nexport function doActionToView(\n  view: GameView,\n  action: GameAction\n): GameView {\n  switch(action.kind) {\n    case 'play-card':\n      const [pid, ipid] = action.premiseIndices\n      return playHandCardTo(view, action.handIndex, pid, ipid) \n    case 'discard':\n      return discardToPile(view, action.handIndex)\n    case 'ergo':\n      return view\n    case 'swap-hand':\n      return swapHandCards(view, action.handIndex1, action.handIndex2)\n  }\n}\n\nexport function playHandCardTo(\n  view: GameView, \n  handCardIndex: number, \n  premiseIndex: number, \n  inPremisePosition: number\n): GameView {\n  const [card, count] = view.handCardWithCount[handCardIndex]\n  const nextHandCards = view.handCardWithCount.slice()\n  const [premise, isLocked] = view.premises[premiseIndex]\n  const nextPremise: [Premise, boolean] = [premise.slice(), isLocked]\n  const nextPremises = view.premises.slice()\n  if (count == 1) {\n    nextHandCards.splice(handCardIndex, 1)\n  } else {\n    nextHandCards[handCardIndex] = [card, count - 1]\n  }\n  nextPremise[0].splice(inPremisePosition, 0, card)\n  nextPremises.splice(premiseIndex, 1, nextPremise)\n\n  console.log(view.premises[premiseIndex].slice())\n  console.log(nextPremise)\n  return {\n    playerVar: view.playerVar,\n    handCardWithCount: nextHandCards,\n    discardPile: [...view.discardPile],\n    premises: nextPremises,\n    deckCount: view.deckCount,\n    goals: view.goals\n  }\n}\n\nexport function discardToPile(\n  view: GameView,\n  handCardIndex: number\n): GameView {\n  const [card, count] = view.handCardWithCount[handCardIndex]\n  const nextHandCards: [Card, number][] = [...view.handCardWithCount]\n  const nextDiscardPile = view.discardPile.slice()\n  if (count == 1) {\n    nextHandCards.splice(handCardIndex, 1)\n    nextDiscardPile.push(card)\n  } else {\n    nextHandCards[handCardIndex] = [card, count - 1]\n  }\n\n  return {\n    playerVar: view.playerVar,\n    handCardWithCount: nextHandCards,\n    discardPile: nextDiscardPile,\n    premises: view.premises.map(([premise, isLocked]) => [premise.slice(), isLocked]),\n    deckCount: view.deckCount,\n    goals: view.goals\n  }\n  \n}\n\nexport function swapHandCards(\n  view: GameView,\n  index1: number,\n  index2: number\n): GameView {\n  let newHand = view.handCardWithCount.slice();\n  [newHand[index1], newHand[index2]] = [newHand[index2], newHand[index1]]\n  return {\n    playerVar: view.playerVar,\n    handCardWithCount: newHand,\n    discardPile: [...view.discardPile],\n    premises: view.premises,\n    deckCount: view.deckCount,\n    goals: view.goals\n  }\n}\n\nexport function getGoalStates(view: GameView): boolean[] {\n  return evalSuccess(view.premises.map(([p, _]) => p), view.goals)\n}\n \nexport function evalSuccess(premises: Premise[], goals: (Goal|undefined)[]): boolean[] {\n  let btrees: BoolTree[] = []\n  try {\n    premises.forEach(premise => {\n      const btree = parsePremise(premise, [\"A\", \"B\", \"C\", \"D\"], OperatorTable.defaultTable())\n      btrees.push(btree)\n    })\n  } catch(e) {\n    return goals.map(_ => false)\n  }\n  \n  const resolver = new PlainResolver([\"A\", \"B\", \"C\", \"D\"])\n  const model = resolver.generateModel(btrees)\n  if (model == undefined) {\n    return goals.map(g => g?.kind == 'paradox' ?? false)\n  }\n  return goals.map(goal => {\n    console.log(goal);\n    if (goal) {\n      switch(goal.kind) {\n        case 'prove': return resolver.canBeProvenBy(btrees, goal.boolTree, true)\n        case 'disprove': return resolver.canBeProvenBy(btrees, goal.boolTree, false)\n        case 'unknown': return resolver.canBeProvenBy(btrees, goal.boolTree, undefined)\n        case 'equivalent': return resolver.isEquivalentTo(btrees, goal.boolTree)\n        case 'tautology': return resolver.isAlwaysTrue(btrees)\n        case 'paradox': return false\n      }\n    }\n    return false\n  })\n}\n\n\nexport function fixInfinityNumber(view: GameView): GameView {\n  view.handCardWithCount = view.handCardWithCount.map(([card, num]) => {\n    return [card, num ? num : Number.POSITIVE_INFINITY]\n  })\n  return view\n}"]},"metadata":{},"sourceType":"module"}