{"ast":null,"code":"import{variable,top}from\"../logicResolver/bools\";import{OperatorTable}from\"./operatorTable\";// export function genTruthTableInString(vars: Card[], premises: Premise[]): TruthTableInString {\n//   const trees = premises.map(p => parsePremiseSafe(p, vars))\n//   if (trees.includes(undefined)) {\n//     const table: TruthTableInString = {}\n//     vars.forEach(v => table[v] = \"-\")\n//     return table\n//   } \n//   return genTruthTableInStringForBTree(vars, trees as BoolTree[])\n// }\nexport function parsePremiseSafe(premise){var variables=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[\"A\",\"B\",\"C\",\"D\"];var operatorTable=arguments.length>2&&arguments[2]!==undefined?arguments[2]:OperatorTable.defaultTable();try{return parsePremise(premise,variables,operatorTable);}catch(e){return undefined;}}export function parsePremise(premise,variables){var operatorTable=arguments.length>2&&arguments[2]!==undefined?arguments[2]:OperatorTable.defaultTable();if(premise.length==0){return top();}var isParenCard=function isParenCard(c){return c==\")\"||c==\"(\";};premise.forEach(function(card){if(!variables.includes(card)&&!operatorTable.isOperator(card)&&!isParenCard(card)){throw Error(\"Unexpected card: \"+card);}});return parsePremiseSection(premise,operatorTable,0,premise.length-1);}// Parse the premise with in a given section suggested by @start and \n// @end (both inclusive), with the provided OperatorTable.\n// Returns the BoolTree if the Parsing is successful.\nfunction parsePremiseSection(premise,operatorTable,start,end){if(start>end){throw new Error(\"premise parse error\");}var pc=undefined;var parenStack=0;// scan through the given section to determine pc\nfor(var i=start;i<=end;i++){var card=premise[i];switch(card){case\"(\":parenStack+=1;break;case\")\":parenStack-=1;// check if parens are unmatched\nif(parenStack<0){throw new Error(\"unmatched parentheses\");}break;default:if(parenStack==0&&operatorTable.isBinaryOperator(card)){var _operatorTable$binOpD=operatorTable.binOpDic[card],p=_operatorTable$binOpD.precedence,fix=_operatorTable$binOpD.fixivity,nodeFunc=_operatorTable$binOpD.nodeFunc;if(pc==undefined||pc.precedence<p||pc.precedence==p&&pc.fixivity=='infixl'){// update pc \npc={card:card,index:i,precedence:p,fixivity:fix,constructor:nodeFunc};}}break;}}if(parenStack!=0){throw new Error(\"unmatched parentheses\");}// If principle connector exists \n// parse lhs and rhs of the pc within this section\n// return constructor(lhs, rhs)\nif(pc!=undefined){var left=parsePremiseSection(premise,operatorTable,start,pc.index-1);var right=parsePremiseSection(premise,operatorTable,pc.index+1,end);return pc.constructor(left,right);}// If the section given is covered by a pair of parentheses\n// Parse the section within that pair of parentheses\nif(premise[start]==\"(\"&&premise[end]==\")\"){return parsePremiseSection(premise,operatorTable,start+1,end-1);}// If the first card in this section is a unary operator card\nvar head=premise[start];if(operatorTable.isUnaryOperator(head)){var child=parsePremiseSection(premise,operatorTable,start+1,end);return operatorTable.unaryOps[head].nodeFunc(child);}// If the section only contain 1 card, and that card is a variable\nif(start==end){return variable(head);}// Otherwise, there is an error\nthrow new Error(\"parse error\");}","map":{"version":3,"sources":["/Users/johnny/IC/Computing/year2/DRP/drp48/src/server/gameApp/game/premise.ts"],"names":["variable","top","OperatorTable","parsePremiseSafe","premise","variables","operatorTable","defaultTable","parsePremise","e","undefined","length","isParenCard","c","forEach","card","includes","isOperator","Error","parsePremiseSection","start","end","pc","parenStack","i","isBinaryOperator","binOpDic","p","precedence","fix","fixivity","nodeFunc","index","constructor","left","right","head","isUnaryOperator","child","unaryOps"],"mappings":"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","sourcesContent":["import { Card, Premise, TruthTableInString } from \"../../../types\"\nimport { BoolTree, variable, top } from \"../logicResolver/bools\"\nimport { OperatorTable, Fixivity, BinaryConstructor } from \"./operatorTable\"\nimport { PlainResolver } from \"../logicResolver/plainResolver\"\n\n// export function genTruthTableInString(vars: Card[], premises: Premise[]): TruthTableInString {\n//   const trees = premises.map(p => parsePremiseSafe(p, vars))\n//   if (trees.includes(undefined)) {\n//     const table: TruthTableInString = {}\n//     vars.forEach(v => table[v] = \"-\")\n//     return table\n//   } \n//   return genTruthTableInStringForBTree(vars, trees as BoolTree[])\n// }\n\nexport function parsePremiseSafe(\n  premise: Premise,\n  variables: Card[] = [\"A\", \"B\", \"C\", \"D\"], \n  operatorTable: OperatorTable = OperatorTable.defaultTable()\n): BoolTree | undefined {\n  try {\n    return parsePremise(premise, variables, operatorTable)\n  } catch(e) {\n    return undefined\n  }\n}\n\nexport function parsePremise(\n  premise: Premise,\n  variables: Card[], \n  operatorTable: OperatorTable = OperatorTable.defaultTable()\n): BoolTree | never {\n  if (premise.length == 0) {\n    return top()\n  }\n  const isParenCard = (c: Card) => c == \")\" || c == \"(\"\n  premise.forEach(card => {\n    if (!variables.includes(card) \n    && !operatorTable.isOperator(card) \n    && !isParenCard(card)) {\n      throw Error(\"Unexpected card: \" + card)\n    }\n  })\n  return parsePremiseSection(premise, operatorTable, 0, premise.length - 1)\n}\n\n// Parse the premise with in a given section suggested by @start and \n// @end (both inclusive), with the provided OperatorTable.\n// Returns the BoolTree if the Parsing is successful.\nfunction parsePremiseSection(\n  premise: Premise, \n  operatorTable: OperatorTable, \n  start: number, \n  end: number\n): BoolTree | never {\n\n  if (start > end) {\n    throw new Error(\"premise parse error\")\n  }\n\n  type PcInfo = { \n    card: Card, \n    index: number, \n    precedence: number, \n    fixivity: Fixivity, \n    constructor: BinaryConstructor \n  }\n\n  let pc: PcInfo | undefined = undefined\n  let parenStack = 0\n  \n  // scan through the given section to determine pc\n  for (let i = start; i <= end; i++) {\n    let card = premise[i]\n    switch(card) {\n      case \"(\":\n        parenStack += 1\n        break\n      case \")\":\n        parenStack -= 1\n        // check if parens are unmatched\n        if (parenStack < 0) {\n          throw new Error(\"unmatched parentheses\")\n        }\n        break\n      default:\n        if (parenStack == 0 && operatorTable.isBinaryOperator(card)) {\n          let { precedence: p, fixivity: fix, nodeFunc: nodeFunc } = operatorTable.binOpDic[card] \n          if (pc == undefined\n          || pc.precedence < p \n          || pc.precedence == p && pc.fixivity == 'infixl') {\n            // update pc \n            pc = {\n              card: card,\n              index: i,\n              precedence: p,\n              fixivity: fix,\n              constructor: nodeFunc\n            }\n          }\n        }\n        break\n    }\n  }\n\n  if (parenStack != 0) {\n    throw new Error(\"unmatched parentheses\")\n  }\n\n  // If principle connector exists \n  // parse lhs and rhs of the pc within this section\n  // return constructor(lhs, rhs)\n  if (pc != undefined) {\n    const left = parsePremiseSection(premise, operatorTable, start, pc.index - 1)\n    const right = parsePremiseSection(premise, operatorTable, pc.index + 1, end)\n    return pc.constructor(left, right)\n  }\n  \n  // If the section given is covered by a pair of parentheses\n  // Parse the section within that pair of parentheses\n  if (premise[start] == \"(\" && premise[end] == \")\") {\n    return parsePremiseSection(premise, operatorTable, start + 1, end - 1)\n  } \n\n  // If the first card in this section is a unary operator card\n  const head = premise[start]\n  if (operatorTable.isUnaryOperator(head)) {\n    const child = parsePremiseSection(premise, operatorTable, start + 1, end)\n    return operatorTable.unaryOps[head].nodeFunc(child)\n  }\n\n  // If the section only contain 1 card, and that card is a variable\n  if (start == end) {\n    return variable(head)\n  }\n\n  // Otherwise, there is an error\n  throw new Error(\"parse error\")\n\n}"]},"metadata":{},"sourceType":"module"}