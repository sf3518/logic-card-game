{"ast":null,"code":"import { PlainResolver } from '../server/gameApp/logicResolver/plainResolver';\nimport { parsePremise } from '../server/gameApp/game/premise';\nimport { OperatorTable } from '../server/gameApp/game/operatorTable';\nexport function doActionToView(view, action) {\n  switch (action.kind) {\n    case 'play-card':\n      const [pid, ipid] = action.premiseIndices;\n      return playHandCardTo(view, action.handIndex, pid, ipid);\n\n    case 'discard':\n      return discardToPile(view, action.handIndex);\n\n    case 'ergo':\n      return view;\n\n    case 'swap-hand':\n      return swapHandCards(view, action.handIndex1, action.handIndex2);\n  }\n}\nexport function playHandCardTo(view, handCardIndex, premiseIndex, inPremisePosition) {\n  const [card, count] = view.handCardWithCount[handCardIndex];\n  const nextHandCards = view.handCardWithCount.slice();\n  const [premise, isLocked] = view.premises[premiseIndex];\n  const nextPremise = [premise.slice(), isLocked];\n  const nextPremises = view.premises.slice();\n\n  if (count == 1) {\n    nextHandCards.splice(handCardIndex, 1);\n  } else {\n    nextHandCards[handCardIndex] = [card, count - 1];\n  }\n\n  nextPremise[0].splice(inPremisePosition, 0, card);\n  nextPremises.splice(premiseIndex, 1, nextPremise);\n  console.log(view.premises[premiseIndex].slice());\n  console.log(nextPremise);\n  return {\n    playerVar: view.playerVar,\n    handCardWithCount: nextHandCards,\n    discardPile: [...view.discardPile],\n    premises: nextPremises,\n    deckCount: view.deckCount,\n    goals: view.goals\n  };\n}\nexport function discardToPile(view, handCardIndex) {\n  const [card, count] = view.handCardWithCount[handCardIndex];\n  const nextHandCards = [...view.handCardWithCount];\n  const nextDiscardPile = view.discardPile.slice();\n\n  if (count == 1) {\n    nextHandCards.splice(handCardIndex, 1);\n    nextDiscardPile.push(card);\n  } else {\n    nextHandCards[handCardIndex] = [card, count - 1];\n  }\n\n  return {\n    playerVar: view.playerVar,\n    handCardWithCount: nextHandCards,\n    discardPile: nextDiscardPile,\n    premises: view.premises.map(([premise, isLocked]) => [premise.slice(), isLocked]),\n    deckCount: view.deckCount,\n    goals: view.goals\n  };\n}\nexport function swapHandCards(view, index1, index2) {\n  let newHand = view.handCardWithCount.slice();\n  [newHand[index1], newHand[index2]] = [newHand[index2], newHand[index1]];\n  return {\n    playerVar: view.playerVar,\n    handCardWithCount: newHand,\n    discardPile: [...view.discardPile],\n    premises: view.premises,\n    deckCount: view.deckCount,\n    goals: view.goals\n  };\n}\nexport function getGoalStates(view) {\n  let btrees = [];\n\n  try {\n    view.premises.forEach(([premise, isLocked]) => {\n      const btree = parsePremise(premise, [\"A\", \"B\", \"C\", \"D\"], OperatorTable.defaultTable());\n      btrees.push(btree);\n    });\n  } catch (e) {\n    return view.goals.map(_ => false);\n  }\n\n  console.log(view.goals);\n  const resolver = new PlainResolver([\"A\", \"B\", \"C\", \"D\"]);\n  const model = resolver.generateModel(btrees);\n\n  if (model == undefined) {\n    return view.goals.map(_ => false);\n  }\n\n  return view.goals.map(goal => {\n    let expected = undefined;\n\n    switch (goal.kind) {\n      case 'prove':\n        expected = true;\n        break;\n\n      case 'disprove':\n        expected = false;\n        break;\n\n      case 'equivalent':\n        return resolver.isEquivalentTo(btrees, goal.boolTree);\n    }\n\n    return resolver.canBeProvenBy(btrees, goal.boolTree, expected);\n  });\n}\nexport function fixInfinityNumber(view) {\n  view.handCardWithCount = view.handCardWithCount.map(([card, num]) => {\n    return [card, num ? num : Number.POSITIVE_INFINITY];\n  });\n  return view;\n}","map":{"version":3,"sources":["/Users/johnny/IC/Computing/DRP/drp48/src/game/views.ts"],"names":["PlainResolver","parsePremise","OperatorTable","doActionToView","view","action","kind","pid","ipid","premiseIndices","playHandCardTo","handIndex","discardToPile","swapHandCards","handIndex1","handIndex2","handCardIndex","premiseIndex","inPremisePosition","card","count","handCardWithCount","nextHandCards","slice","premise","isLocked","premises","nextPremise","nextPremises","splice","console","log","playerVar","discardPile","deckCount","goals","nextDiscardPile","push","map","index1","index2","newHand","getGoalStates","btrees","forEach","btree","defaultTable","e","_","resolver","model","generateModel","undefined","goal","expected","isEquivalentTo","boolTree","canBeProvenBy","fixInfinityNumber","num","Number","POSITIVE_INFINITY"],"mappings":"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","sourcesContent":["import { GameView, GameAction, Card, Premise } from '../types'\nimport { BoolTree } from '../server/gameApp/logicResolver/bools'\nimport { allPossibleTruthTablesOf, PlainResolver, modelProves } from '../server/gameApp/logicResolver/plainResolver'\nimport { parsePremise } from '../server/gameApp/game/premise'\nimport { Model } from '../server/gameApp/logicResolver/resolver'\nimport { OperatorTable } from '../server/gameApp/game/operatorTable'\n\nexport function doActionToView(\n  view: GameView,\n  action: GameAction\n): GameView {\n  switch(action.kind) {\n    case 'play-card':\n      const [pid, ipid] = action.premiseIndices\n      return playHandCardTo(view, action.handIndex, pid, ipid) \n    case 'discard':\n      return discardToPile(view, action.handIndex)\n    case 'ergo':\n      return view\n    case 'swap-hand':\n      return swapHandCards(view, action.handIndex1, action.handIndex2)\n  }\n}\n\nexport function playHandCardTo(\n  view: GameView, \n  handCardIndex: number, \n  premiseIndex: number, \n  inPremisePosition: number\n): GameView {\n  const [card, count] = view.handCardWithCount[handCardIndex]\n  const nextHandCards = view.handCardWithCount.slice()\n  const [premise, isLocked] = view.premises[premiseIndex]\n  const nextPremise: [Premise, boolean] = [premise.slice(), isLocked]\n  const nextPremises = view.premises.slice()\n  if (count == 1) {\n    nextHandCards.splice(handCardIndex, 1)\n  } else {\n    nextHandCards[handCardIndex] = [card, count - 1]\n  }\n  nextPremise[0].splice(inPremisePosition, 0, card)\n  nextPremises.splice(premiseIndex, 1, nextPremise)\n\n  console.log(view.premises[premiseIndex].slice())\n  console.log(nextPremise)\n  return {\n    playerVar: view.playerVar,\n    handCardWithCount: nextHandCards,\n    discardPile: [...view.discardPile],\n    premises: nextPremises,\n    deckCount: view.deckCount,\n    goals: view.goals\n  }\n}\n\nexport function discardToPile(\n  view: GameView,\n  handCardIndex: number\n): GameView {\n  const [card, count] = view.handCardWithCount[handCardIndex]\n  const nextHandCards: [Card, number][] = [...view.handCardWithCount]\n  const nextDiscardPile = view.discardPile.slice()\n  if (count == 1) {\n    nextHandCards.splice(handCardIndex, 1)\n    nextDiscardPile.push(card)\n  } else {\n    nextHandCards[handCardIndex] = [card, count - 1]\n  }\n\n  return {\n    playerVar: view.playerVar,\n    handCardWithCount: nextHandCards,\n    discardPile: nextDiscardPile,\n    premises: view.premises.map(([premise, isLocked]) => [premise.slice(), isLocked]),\n    deckCount: view.deckCount,\n    goals: view.goals\n  }\n  \n}\n\nexport function swapHandCards(\n  view: GameView,\n  index1: number,\n  index2: number\n): GameView {\n  let newHand = view.handCardWithCount.slice();\n  [newHand[index1], newHand[index2]] = [newHand[index2], newHand[index1]]\n  return {\n    playerVar: view.playerVar,\n    handCardWithCount: newHand,\n    discardPile: [...view.discardPile],\n    premises: view.premises,\n    deckCount: view.deckCount,\n    goals: view.goals\n  }\n}\n\nexport function getGoalStates(view: GameView): boolean[] {\n  let btrees: BoolTree[] = []\n  try {\n    view.premises.forEach(([premise, isLocked]) => {\n      const btree = parsePremise(premise, [\"A\", \"B\", \"C\", \"D\"], OperatorTable.defaultTable())\n      btrees.push(btree)\n    })\n  } catch(e) {\n    return view.goals.map(_ => false)\n  }\n  console.log(view.goals);\n  \n  const resolver = new PlainResolver([\"A\", \"B\", \"C\", \"D\"])\n  const model = resolver.generateModel(btrees)\n  if (model == undefined) {\n    return view.goals.map(_ => false)\n  }\n  return view.goals.map(goal => {\n    let expected: boolean | undefined = undefined\n    switch(goal.kind) {\n      case 'prove': expected = true; break\n      case 'disprove': expected = false; break\n      case 'equivalent': return resolver.isEquivalentTo(btrees, goal.boolTree)\n    }\n    \n    return resolver.canBeProvenBy(btrees, goal.boolTree, expected)\n  })\n}\n\n\nexport function fixInfinityNumber(view: GameView): GameView {\n  view.handCardWithCount = view.handCardWithCount.map(([card, num]) => {\n    return [card, num ? num : Number.POSITIVE_INFINITY]\n  })\n  return view\n}"]},"metadata":{},"sourceType":"module"}